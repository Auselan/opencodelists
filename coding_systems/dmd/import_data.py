import glob
import os

from django.db import connection, transaction
from django.db.models import fields as django_fields
from lxml import etree

from . import models


@transaction.atomic
def import_data(release_dir):
    # dm+d data is provided in several XML files:
    #
    # * f_amp2_3[ddmmyy].xml
    # * f_ampp2_3[ddmmyy].xml
    # * f_gtin2_0[ddmmyy].xml
    # * f_ingredient2_3[ddmmyy].xml
    # * f_lookup2_3[ddmmyy].xml
    # * f_vmp2_3[ddmmyy].xml
    # * f_vmpp2_3[ddmmyy].xml
    # * f_vtm2_3[ddmmyy].xml
    #
    # Each file contains a list or lists of elements that correspond to
    # instances of one of the models in models.py.
    #
    # Each such element has the structure:
    #
    # <OBJ_TYPE>
    #   <FIELD1>value</FIELD1>
    #   <FIELD2>value</FIELD2>
    #   <FIELD3>value</FIELD3>
    # </OBJ_TYPE>
    #
    # These elements are arranged differently in different files.
    #
    # The ingredient and VTM files just contain a list of elements
    # corresponding to instances of Ing and VTM respectively.  For
    # instance:
    #
    # <INGREDIENT_SUBSTANCES>
    #     <!-- Generated by NHSBSA PPD -->
    #     <ING>...</ING>
    #     <ING>...</ING>
    #     ...
    # </INGREDIENT_SUBSTANCES>
    #
    # The VMP, VMPP, AMP, AMPP and lookup files contain several lists of
    # elements, corresponding to multiple types of objects.  For instance:
    #
    # <VIRTUAL_MED_PRODUCTS>
    #     <!-- Generated by NHSBSA PPD -->
    #     <VMPS>
    #         <VMP>...</VMP>
    #         <VMP>...</VMP>
    #         ...
    #     </VMPS>
    #     <VIRTUAL_PRODUCT_INGREDIENT>
    #         <VPI>...</VPI>
    #         <VPI>...</VPI>
    #         ...
    #     </VIRTUAL_PRODUCT_INGREDIENT>
    #     <ONT_DRUG_FORM>
    #         <ONT>...</ONT>
    #         <ONT>...</ONT>
    #         ...
    #     </ONT_DRUG_FORM>
    #     ...
    # <VIRTUAL_MED_PRODUCTS>
    #
    # The GTIN file is a bit weird and the data requires a little massaging
    # before it can be imported.  See code below.
    #
    # Since the data model contains foreign key constraints, the order we
    # import the files is significant.
    #
    # When importing the data, we first delete all existing instances,
    # because the IDs of some SNOMED objects can change.

    # lookup
    for elements in load_elements(release_dir, "lookup"):
        model_name = make_model_name(elements.tag)
        model = getattr(models, model_name)
        import_model(model, elements)

    # ingredient
    elements = load_elements(release_dir, "ingredient")
    import_model(models.Ing, elements)

    # vtm
    elements = load_elements(release_dir, "vtm")
    import_model(models.VTM, elements)

    # vmp
    for elements in load_elements(release_dir, "vmp"):
        model_name = make_model_name(elements[0].tag)
        model = getattr(models, model_name)
        import_model(model, elements)

    # vmpp
    for elements in load_elements(release_dir, "vmpp"):
        if elements[0].tag == "CCONTENT":
            # We don't yet handle the CCONTENT tag, which indicates that a
            # VMPP is part of a combination pack, where two VMPPs are
            # always prescribed together.
            continue

        model_name = make_model_name(elements[0].tag)
        model = getattr(models, model_name)
        import_model(model, elements)

    # amp
    for elements in load_elements(release_dir, "amp"):
        if len(elements) == 0:
            # For test data, some lists of elements are empty (eg
            # AP_INFORMATION), and so we can't look at the first element of
            # the list to get the name of the corresponding model.
            continue

        model_name = make_model_name(elements[0].tag)
        model = getattr(models, model_name)
        import_model(model, elements)

    # ampp
    for elements in load_elements(release_dir, "ampp"):
        if len(elements) == 0:
            # For test data, some lists of elements are empty (eg
            # APPLIANCE_PACK_INFO), and so we can't look at the first
            # element of the list to get the name of the corresponding
            # model.
            continue

        if elements[0].tag == "CCONTENT":
            # We don't yet handle the CCONTENT tag, which indicates that a
            # AMPP is part of a combination pack, where two AMPPs are
            # always prescribed together.
            continue

        model_name = make_model_name(elements[0].tag)
        model = getattr(models, model_name)
        import_model(model, elements)

    # gtin
    elements = load_elements(release_dir, "gtin")[0]
    for element in elements:
        assert element[0].tag == "AMPPID"
        assert element[1].tag == "GTINDATA"

        element[0].tag = "APPID"
        for gtinelt in element[1]:
            element.append(gtinelt)
        element.remove(element[1])
    import_model(models.GTIN, elements)


def load_elements(release_dir, filename_fragment):
    """Return list of non-comment top-level elements in given file."""

    paths = glob.glob(
        os.path.join(release_dir, "f_{}2_*.xml".format(filename_fragment))
    )
    assert len(paths) == 1

    with open(paths[0]) as f:
        doc = etree.parse(f)

    root = doc.getroot()
    elements = list(root)
    assert isinstance(elements[0], etree._Comment)
    return elements[1:]


def import_model(model, elements):
    """Import model instances from list of XML elements."""

    model.objects.all().delete()

    boolean_field_names = [
        f.name for f in model._meta.fields if isinstance(f, django_fields.BooleanField)
    ]

    table_name = model._meta.db_table
    column_names = [
        f.db_column or f.name
        for f in model._meta.fields
        if not isinstance(f, django_fields.AutoField)
    ]
    sql = "INSERT INTO {} ({}) VALUES ({})".format(
        table_name, ", ".join(column_names), ", ".join(["%s"] * len(column_names))
    )

    values = []

    for element in elements:
        row = {}

        for field_element in element:
            name = field_element.tag.lower()
            if name == "desc":
                # "desc" is a really unhelpful field name if you're writing
                # SQL!
                name = "descr"
            elif name == "dnd":
                # For consistency with the rest of the data, we rename
                # "dnd" to "dndcd", as it is a foreign key field.
                name = "dndcd"

            value = field_element.text
            row[name] = value

        for name in boolean_field_names:
            row[name] = name in row

        values.append([row.get(name) for name in column_names])

    with connection.cursor() as cursor:
        cursor.executemany(sql, values)


def make_model_name(tag_name):
    """Construct name of Django model from XML tag name."""

    if tag_name in ["VTM", "VPI", "VMP", "VMPP", "AMP", "AMPP", "GTIN"]:
        return tag_name
    else:
        return "".join(tok.title() for tok in tag_name.split("_"))
