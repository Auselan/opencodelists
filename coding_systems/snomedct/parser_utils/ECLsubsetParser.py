# Generated from ECLsubset.g4 by ANTLR 4.9.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3e")
        buf.write("\u015e\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\3\2\3")
        buf.write("\2\3\2\5\2N\n\2\3\2\3\2\3\3\3\3\5\3T\n\3\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\6\4\\\n\4\r\4\16\4]\3\5\3\5\3\5\3\5\3\5\3\5")
        buf.write("\3\6\3\6\3\6\5\6i\n\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6")
        buf.write("r\n\6\3\7\3\7\3\b\3\b\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n")
        buf.write("\5\n\u0080\n\n\3\13\3\13\3\f\3\f\3\f\3\r\3\r\3\r\3\16")
        buf.write("\3\16\3\17\3\17\3\17\3\20\3\20\3\20\3\21\3\21\3\21\3\21")
        buf.write("\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\5\23\u00a4\n\23\3\23\3\23\3\23\3\23\3")
        buf.write("\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\5\23\u00fe\n\23\3")
        buf.write("\24\3\24\3\24\3\24\3\24\7\24\u0105\n\24\f\24\16\24\u0108")
        buf.write("\13\24\3\25\3\25\3\25\3\25\3\25\6\25\u010f\n\25\r\25\16")
        buf.write("\25\u0110\3\26\3\26\3\26\3\26\3\26\7\26\u0118\n\26\f\26")
        buf.write("\16\26\u011b\13\26\3\26\3\26\3\26\3\27\3\27\3\27\3\27")
        buf.write("\3\27\3\27\3\27\5\27\u0127\n\27\3\30\3\30\3\30\3\31\3")
        buf.write("\31\3\31\3\31\3\31\3\31\3\31\5\31\u0133\n\31\3\32\3\32")
        buf.write("\3\33\3\33\3\34\3\34\3\35\3\35\3\36\3\36\3\37\3\37\3 ")
        buf.write("\3 \3!\3!\3\"\3\"\3#\3#\3#\5#\u014a\n#\3$\3$\3$\3$\3$")
        buf.write("\3$\3$\3$\5$\u0154\n$\3%\3%\3%\3%\3%\3%\5%\u015c\n%\3")
        buf.write("%\2\2&\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,")
        buf.write(".\60\62\64\668:<>@BDFH\2\24\4\2\66\66VV\4\299YY\4\2\64")
        buf.write("\64TT\4\2\60\60PP\4\2\65\65UU\4\2<<\\\\\4\2::ZZ\3\2\b")
        buf.write("\20\3\2\22e\3\2\b\25\3\2\27e\3\2\27 \3\2\30 \3\2\bb\3")
        buf.write("\2de\3\2\7\b\3\2\nB\3\2De\2\u0171\2J\3\2\2\2\4S\3\2\2")
        buf.write("\2\6U\3\2\2\2\b_\3\2\2\2\nh\3\2\2\2\fs\3\2\2\2\16u\3\2")
        buf.write("\2\2\20w\3\2\2\2\22\177\3\2\2\2\24\u0081\3\2\2\2\26\u0083")
        buf.write("\3\2\2\2\30\u0086\3\2\2\2\32\u0089\3\2\2\2\34\u008b\3")
        buf.write("\2\2\2\36\u008e\3\2\2\2 \u0091\3\2\2\2\"\u0095\3\2\2\2")
        buf.write("$\u009c\3\2\2\2&\u0106\3\2\2\2(\u010e\3\2\2\2*\u0112\3")
        buf.write("\2\2\2,\u0126\3\2\2\2.\u0128\3\2\2\2\60\u0132\3\2\2\2")
        buf.write("\62\u0134\3\2\2\2\64\u0136\3\2\2\2\66\u0138\3\2\2\28\u013a")
        buf.write("\3\2\2\2:\u013c\3\2\2\2<\u013e\3\2\2\2>\u0140\3\2\2\2")
        buf.write("@\u0142\3\2\2\2B\u0144\3\2\2\2D\u0149\3\2\2\2F\u0153\3")
        buf.write("\2\2\2H\u015b\3\2\2\2JM\5&\24\2KN\5\4\3\2LN\5\n\6\2MK")
        buf.write("\3\2\2\2ML\3\2\2\2NO\3\2\2\2OP\5&\24\2P\3\3\2\2\2QT\5")
        buf.write("\6\4\2RT\5\b\5\2SQ\3\2\2\2SR\3\2\2\2T\5\3\2\2\2U[\5\n")
        buf.write("\6\2VW\5&\24\2WX\5 \21\2XY\5&\24\2YZ\5\n\6\2Z\\\3\2\2")
        buf.write("\2[V\3\2\2\2\\]\3\2\2\2][\3\2\2\2]^\3\2\2\2^\7\3\2\2\2")
        buf.write("_`\5\n\6\2`a\5&\24\2ab\5\"\22\2bc\5&\24\2cd\5\n\6\2d\t")
        buf.write("\3\2\2\2ef\5\22\n\2fg\5&\24\2gi\3\2\2\2he\3\2\2\2hi\3")
        buf.write("\2\2\2iq\3\2\2\2jr\5\f\7\2kl\7\17\2\2lm\5&\24\2mn\5\2")
        buf.write("\2\2no\5&\24\2op\7\20\2\2pr\3\2\2\2qj\3\2\2\2qk\3\2\2")
        buf.write("\2r\13\3\2\2\2st\5\16\b\2t\r\3\2\2\2uv\5\20\t\2v\17\3")
        buf.write("\2\2\2wx\5$\23\2x\21\3\2\2\2y\u0080\5\30\r\2z\u0080\5")
        buf.write("\26\f\2{\u0080\5\24\13\2|\u0080\5\36\20\2}\u0080\5\34")
        buf.write("\17\2~\u0080\5\32\16\2\177y\3\2\2\2\177z\3\2\2\2\177{")
        buf.write("\3\2\2\2\177|\3\2\2\2\177}\3\2\2\2\177~\3\2\2\2\u0080")
        buf.write("\23\3\2\2\2\u0081\u0082\7#\2\2\u0082\25\3\2\2\2\u0083")
        buf.write("\u0084\7#\2\2\u0084\u0085\7#\2\2\u0085\27\3\2\2\2\u0086")
        buf.write("\u0087\7#\2\2\u0087\u0088\7\b\2\2\u0088\31\3\2\2\2\u0089")
        buf.write("\u008a\7%\2\2\u008a\33\3\2\2\2\u008b\u008c\7%\2\2\u008c")
        buf.write("\u008d\7%\2\2\u008d\35\3\2\2\2\u008e\u008f\7%\2\2\u008f")
        buf.write("\u0090\7\b\2\2\u0090\37\3\2\2\2\u0091\u0092\t\2\2\2\u0092")
        buf.write("\u0093\t\3\2\2\u0093\u0094\5(\25\2\u0094!\3\2\2\2\u0095")
        buf.write("\u0096\t\4\2\2\u0096\u0097\t\5\2\2\u0097\u0098\t\6\2\2")
        buf.write("\u0098\u0099\t\7\2\2\u0099\u009a\t\b\2\2\u009a\u009b\5")
        buf.write("(\25\2\u009b#\3\2\2\2\u009c\u009d\5B\"\2\u009d\u009e\5")
        buf.write("> \2\u009e\u009f\5> \2\u009f\u00a0\5> \2\u00a0\u00a1\5")
        buf.write("> \2\u00a1\u00fd\5> \2\u00a2\u00a4\5> \2\u00a3\u00a2\3")
        buf.write("\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00fe\3\2\2\2\u00a5\u00a6")
        buf.write("\5> \2\u00a6\u00a7\5> \2\u00a7\u00fe\3\2\2\2\u00a8\u00a9")
        buf.write("\5> \2\u00a9\u00aa\5> \2\u00aa\u00ab\5> \2\u00ab\u00fe")
        buf.write("\3\2\2\2\u00ac\u00ad\5> \2\u00ad\u00ae\5> \2\u00ae\u00af")
        buf.write("\5> \2\u00af\u00b0\5> \2\u00b0\u00fe\3\2\2\2\u00b1\u00b2")
        buf.write("\5> \2\u00b2\u00b3\5> \2\u00b3\u00b4\5> \2\u00b4\u00b5")
        buf.write("\5> \2\u00b5\u00b6\5> \2\u00b6\u00fe\3\2\2\2\u00b7\u00b8")
        buf.write("\5> \2\u00b8\u00b9\5> \2\u00b9\u00ba\5> \2\u00ba\u00bb")
        buf.write("\5> \2\u00bb\u00bc\5> \2\u00bc\u00bd\5> \2\u00bd\u00fe")
        buf.write("\3\2\2\2\u00be\u00bf\5> \2\u00bf\u00c0\5> \2\u00c0\u00c1")
        buf.write("\5> \2\u00c1\u00c2\5> \2\u00c2\u00c3\5> \2\u00c3\u00c4")
        buf.write("\5> \2\u00c4\u00c5\5> \2\u00c5\u00fe\3\2\2\2\u00c6\u00c7")
        buf.write("\5> \2\u00c7\u00c8\5> \2\u00c8\u00c9\5> \2\u00c9\u00ca")
        buf.write("\5> \2\u00ca\u00cb\5> \2\u00cb\u00cc\5> \2\u00cc\u00cd")
        buf.write("\5> \2\u00cd\u00ce\5> \2\u00ce\u00fe\3\2\2\2\u00cf\u00d0")
        buf.write("\5> \2\u00d0\u00d1\5> \2\u00d1\u00d2\5> \2\u00d2\u00d3")
        buf.write("\5> \2\u00d3\u00d4\5> \2\u00d4\u00d5\5> \2\u00d5\u00d6")
        buf.write("\5> \2\u00d6\u00d7\5> \2\u00d7\u00d8\5> \2\u00d8\u00fe")
        buf.write("\3\2\2\2\u00d9\u00da\5> \2\u00da\u00db\5> \2\u00db\u00dc")
        buf.write("\5> \2\u00dc\u00dd\5> \2\u00dd\u00de\5> \2\u00de\u00df")
        buf.write("\5> \2\u00df\u00e0\5> \2\u00e0\u00e1\5> \2\u00e1\u00e2")
        buf.write("\5> \2\u00e2\u00e3\5> \2\u00e3\u00fe\3\2\2\2\u00e4\u00e5")
        buf.write("\5> \2\u00e5\u00e6\5> \2\u00e6\u00e7\5> \2\u00e7\u00e8")
        buf.write("\5> \2\u00e8\u00e9\5> \2\u00e9\u00ea\5> \2\u00ea\u00eb")
        buf.write("\5> \2\u00eb\u00ec\5> \2\u00ec\u00ed\5> \2\u00ed\u00ee")
        buf.write("\5> \2\u00ee\u00ef\5> \2\u00ef\u00fe\3\2\2\2\u00f0\u00f1")
        buf.write("\5> \2\u00f1\u00f2\5> \2\u00f2\u00f3\5> \2\u00f3\u00f4")
        buf.write("\5> \2\u00f4\u00f5\5> \2\u00f5\u00f6\5> \2\u00f6\u00f7")
        buf.write("\5> \2\u00f7\u00f8\5> \2\u00f8\u00f9\5> \2\u00f9\u00fa")
        buf.write("\5> \2\u00fa\u00fb\5> \2\u00fb\u00fc\5> \2\u00fc\u00fe")
        buf.write("\3\2\2\2\u00fd\u00a3\3\2\2\2\u00fd\u00a5\3\2\2\2\u00fd")
        buf.write("\u00a8\3\2\2\2\u00fd\u00ac\3\2\2\2\u00fd\u00b1\3\2\2\2")
        buf.write("\u00fd\u00b7\3\2\2\2\u00fd\u00be\3\2\2\2\u00fd\u00c6\3")
        buf.write("\2\2\2\u00fd\u00cf\3\2\2\2\u00fd\u00d9\3\2\2\2\u00fd\u00e4")
        buf.write("\3\2\2\2\u00fd\u00f0\3\2\2\2\u00fe%\3\2\2\2\u00ff\u0105")
        buf.write("\5\62\32\2\u0100\u0105\5\64\33\2\u0101\u0105\5\66\34\2")
        buf.write("\u0102\u0105\58\35\2\u0103\u0105\5*\26\2\u0104\u00ff\3")
        buf.write("\2\2\2\u0104\u0100\3\2\2\2\u0104\u0101\3\2\2\2\u0104\u0102")
        buf.write("\3\2\2\2\u0104\u0103\3\2\2\2\u0105\u0108\3\2\2\2\u0106")
        buf.write("\u0104\3\2\2\2\u0106\u0107\3\2\2\2\u0107\'\3\2\2\2\u0108")
        buf.write("\u0106\3\2\2\2\u0109\u010f\5\62\32\2\u010a\u010f\5\64")
        buf.write("\33\2\u010b\u010f\5\66\34\2\u010c\u010f\58\35\2\u010d")
        buf.write("\u010f\5*\26\2\u010e\u0109\3\2\2\2\u010e\u010a\3\2\2\2")
        buf.write("\u010e\u010b\3\2\2\2\u010e\u010c\3\2\2\2\u010e\u010d\3")
        buf.write("\2\2\2\u010f\u0110\3\2\2\2\u0110\u010e\3\2\2\2\u0110\u0111")
        buf.write("\3\2\2\2\u0111)\3\2\2\2\u0112\u0113\7\26\2\2\u0113\u0114")
        buf.write("\7\21\2\2\u0114\u0119\3\2\2\2\u0115\u0118\5,\27\2\u0116")
        buf.write("\u0118\5.\30\2\u0117\u0115\3\2\2\2\u0117\u0116\3\2\2\2")
        buf.write("\u0118\u011b\3\2\2\2\u0119\u0117\3\2\2\2\u0119\u011a\3")
        buf.write("\2\2\2\u011a\u011c\3\2\2\2\u011b\u0119\3\2\2\2\u011c\u011d")
        buf.write("\7\21\2\2\u011d\u011e\7\26\2\2\u011e+\3\2\2\2\u011f\u0127")
        buf.write("\5\62\32\2\u0120\u0127\5\64\33\2\u0121\u0127\5\66\34\2")
        buf.write("\u0122\u0127\58\35\2\u0123\u0127\t\t\2\2\u0124\u0127\t")
        buf.write("\n\2\2\u0125\u0127\7\3\2\2\u0126\u011f\3\2\2\2\u0126\u0120")
        buf.write("\3\2\2\2\u0126\u0121\3\2\2\2\u0126\u0122\3\2\2\2\u0126")
        buf.write("\u0123\3\2\2\2\u0126\u0124\3\2\2\2\u0126\u0125\3\2\2\2")
        buf.write("\u0127-\3\2\2\2\u0128\u0129\7\21\2\2\u0129\u012a\5\60")
        buf.write("\31\2\u012a/\3\2\2\2\u012b\u0133\5\62\32\2\u012c\u0133")
        buf.write("\5\64\33\2\u012d\u0133\5\66\34\2\u012e\u0133\58\35\2\u012f")
        buf.write("\u0133\t\13\2\2\u0130\u0133\t\f\2\2\u0131\u0133\7\3\2")
        buf.write("\2\u0132\u012b\3\2\2\2\u0132\u012c\3\2\2\2\u0132\u012d")
        buf.write("\3\2\2\2\u0132\u012e\3\2\2\2\u0132\u012f\3\2\2\2\u0132")
        buf.write("\u0130\3\2\2\2\u0132\u0131\3\2\2\2\u0133\61\3\2\2\2\u0134")
        buf.write("\u0135\7\7\2\2\u0135\63\3\2\2\2\u0136\u0137\7\4\2\2\u0137")
        buf.write("\65\3\2\2\2\u0138\u0139\7\6\2\2\u0139\67\3\2\2\2\u013a")
        buf.write("\u013b\7\5\2\2\u013b9\3\2\2\2\u013c\u013d\7\t\2\2\u013d")
        buf.write(";\3\2\2\2\u013e\u013f\7C\2\2\u013f=\3\2\2\2\u0140\u0141")
        buf.write("\t\r\2\2\u0141?\3\2\2\2\u0142\u0143\7\27\2\2\u0143A\3")
        buf.write("\2\2\2\u0144\u0145\t\16\2\2\u0145C\3\2\2\2\u0146\u014a")
        buf.write("\t\17\2\2\u0147\u014a\t\20\2\2\u0148\u014a\7\3\2\2\u0149")
        buf.write("\u0146\3\2\2\2\u0149\u0147\3\2\2\2\u0149\u0148\3\2\2\2")
        buf.write("\u014aE\3\2\2\2\u014b\u0154\5\62\32\2\u014c\u0154\5\64")
        buf.write("\33\2\u014d\u0154\5\66\34\2\u014e\u0154\58\35\2\u014f")
        buf.write("\u0154\t\21\2\2\u0150\u0154\t\22\2\2\u0151\u0154\t\23")
        buf.write("\2\2\u0152\u0154\7\3\2\2\u0153\u014b\3\2\2\2\u0153\u014c")
        buf.write("\3\2\2\2\u0153\u014d\3\2\2\2\u0153\u014e\3\2\2\2\u0153")
        buf.write("\u014f\3\2\2\2\u0153\u0150\3\2\2\2\u0153\u0151\3\2\2\2")
        buf.write("\u0153\u0152\3\2\2\2\u0154G\3\2\2\2\u0155\u0156\5<\37")
        buf.write("\2\u0156\u0157\5:\36\2\u0157\u015c\3\2\2\2\u0158\u0159")
        buf.write("\5<\37\2\u0159\u015a\5<\37\2\u015a\u015c\3\2\2\2\u015b")
        buf.write("\u0155\3\2\2\2\u015b\u0158\3\2\2\2\u015cI\3\2\2\2\25M")
        buf.write("S]hq\177\u00a3\u00fd\u0104\u0106\u010e\u0110\u0117\u0119")
        buf.write("\u0126\u0132\u0149\u0153\u015b")
        return buf.getvalue()


class ECLsubsetParser ( Parser ):

    grammarFileName = "ECLsubset.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'\u0009'", "'\u000A'", "'\u000D'", 
                     "' '", "'!'", "'\"'", "'#'", "'$'", "'%'", "'&'", "'''", 
                     "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'/'", 
                     "'0'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", 
                     "'8'", "'9'", "':'", "';'", "'<'", "'='", "'>'", "'?'", 
                     "'@'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", 
                     "'H'", "'I'", "'J'", "'K'", "'L'", "'M'", "'N'", "'O'", 
                     "'P'", "'Q'", "'R'", "'S'", "'T'", "'U'", "'V'", "'W'", 
                     "'X'", "'Y'", "'Z'", "'['", "'\\'", "']'", "'^'", "'_'", 
                     "'`'", "'a'", "'b'", "'c'", "'d'", "'e'", "'f'", "'g'", 
                     "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", 
                     "'p'", "'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", 
                     "'x'", "'y'", "'z'", "'{'", "'|'", "'}'", "'~'" ]

    symbolicNames = [ "<INVALID>", "UTF8_LETTER", "TAB", "LF", "CR", "SPACE", 
                      "EXCLAMATION", "QUOTE", "POUND", "DOLLAR", "PERCENT", 
                      "AMPERSAND", "APOSTROPHE", "LEFT_PAREN", "RIGHT_PAREN", 
                      "ASTERISK", "PLUS", "COMMA", "DASH", "PERIOD", "SLASH", 
                      "ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", 
                      "SEVEN", "EIGHT", "NINE", "COLON", "SEMICOLON", "LESS_THAN", 
                      "EQUALS", "GREATER_THAN", "QUESTION", "AT", "CAP_A", 
                      "CAP_B", "CAP_C", "CAP_D", "CAP_E", "CAP_F", "CAP_G", 
                      "CAP_H", "CAP_I", "CAP_J", "CAP_K", "CAP_L", "CAP_M", 
                      "CAP_N", "CAP_O", "CAP_P", "CAP_Q", "CAP_R", "CAP_S", 
                      "CAP_T", "CAP_U", "CAP_V", "CAP_W", "CAP_X", "CAP_Y", 
                      "CAP_Z", "LEFT_BRACE", "BACKSLASH", "RIGHT_BRACE", 
                      "CARAT", "UNDERSCORE", "ACCENT", "A", "B", "C", "D", 
                      "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", 
                      "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", 
                      "Y", "Z", "LEFT_CURLY_BRACE", "PIPE", "RIGHT_CURLY_BRACE", 
                      "TILDE" ]

    RULE_expressionconstraint = 0
    RULE_compoundexpressionconstraint = 1
    RULE_disjunctionexpressionconstraint = 2
    RULE_exclusionexpressionconstraint = 3
    RULE_subexpressionconstraint = 4
    RULE_eclfocusconcept = 5
    RULE_eclconceptreference = 6
    RULE_conceptid = 7
    RULE_constraintoperator = 8
    RULE_descendantof = 9
    RULE_descendantorselfof = 10
    RULE_childof = 11
    RULE_ancestorof = 12
    RULE_ancestororselfof = 13
    RULE_parentof = 14
    RULE_disjunction = 15
    RULE_exclusion = 16
    RULE_sctid = 17
    RULE_ws = 18
    RULE_mws = 19
    RULE_comment = 20
    RULE_nonstarchar = 21
    RULE_starwithnonfslash = 22
    RULE_nonfslash = 23
    RULE_sp = 24
    RULE_htab = 25
    RULE_cr = 26
    RULE_lf = 27
    RULE_qm = 28
    RULE_bs = 29
    RULE_digit = 30
    RULE_zero = 31
    RULE_digitnonzero = 32
    RULE_nonwsnonpipe = 33
    RULE_anynonescapedchar = 34
    RULE_escapedchar = 35

    ruleNames =  [ "expressionconstraint", "compoundexpressionconstraint", 
                   "disjunctionexpressionconstraint", "exclusionexpressionconstraint", 
                   "subexpressionconstraint", "eclfocusconcept", "eclconceptreference", 
                   "conceptid", "constraintoperator", "descendantof", "descendantorselfof", 
                   "childof", "ancestorof", "ancestororselfof", "parentof", 
                   "disjunction", "exclusion", "sctid", "ws", "mws", "comment", 
                   "nonstarchar", "starwithnonfslash", "nonfslash", "sp", 
                   "htab", "cr", "lf", "qm", "bs", "digit", "zero", "digitnonzero", 
                   "nonwsnonpipe", "anynonescapedchar", "escapedchar" ]

    EOF = Token.EOF
    UTF8_LETTER=1
    TAB=2
    LF=3
    CR=4
    SPACE=5
    EXCLAMATION=6
    QUOTE=7
    POUND=8
    DOLLAR=9
    PERCENT=10
    AMPERSAND=11
    APOSTROPHE=12
    LEFT_PAREN=13
    RIGHT_PAREN=14
    ASTERISK=15
    PLUS=16
    COMMA=17
    DASH=18
    PERIOD=19
    SLASH=20
    ZERO=21
    ONE=22
    TWO=23
    THREE=24
    FOUR=25
    FIVE=26
    SIX=27
    SEVEN=28
    EIGHT=29
    NINE=30
    COLON=31
    SEMICOLON=32
    LESS_THAN=33
    EQUALS=34
    GREATER_THAN=35
    QUESTION=36
    AT=37
    CAP_A=38
    CAP_B=39
    CAP_C=40
    CAP_D=41
    CAP_E=42
    CAP_F=43
    CAP_G=44
    CAP_H=45
    CAP_I=46
    CAP_J=47
    CAP_K=48
    CAP_L=49
    CAP_M=50
    CAP_N=51
    CAP_O=52
    CAP_P=53
    CAP_Q=54
    CAP_R=55
    CAP_S=56
    CAP_T=57
    CAP_U=58
    CAP_V=59
    CAP_W=60
    CAP_X=61
    CAP_Y=62
    CAP_Z=63
    LEFT_BRACE=64
    BACKSLASH=65
    RIGHT_BRACE=66
    CARAT=67
    UNDERSCORE=68
    ACCENT=69
    A=70
    B=71
    C=72
    D=73
    E=74
    F=75
    G=76
    H=77
    I=78
    J=79
    K=80
    L=81
    M=82
    N=83
    O=84
    P=85
    Q=86
    R=87
    S=88
    T=89
    U=90
    V=91
    W=92
    X=93
    Y=94
    Z=95
    LEFT_CURLY_BRACE=96
    PIPE=97
    RIGHT_CURLY_BRACE=98
    TILDE=99

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ExpressionconstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ws(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.WsContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.WsContext,i)


        def compoundexpressionconstraint(self):
            return self.getTypedRuleContext(ECLsubsetParser.CompoundexpressionconstraintContext,0)


        def subexpressionconstraint(self):
            return self.getTypedRuleContext(ECLsubsetParser.SubexpressionconstraintContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_expressionconstraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionconstraint" ):
                return visitor.visitExpressionconstraint(self)
            else:
                return visitor.visitChildren(self)




    def expressionconstraint(self):

        localctx = ECLsubsetParser.ExpressionconstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_expressionconstraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.ws()
            self.state = 75
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 73
                self.compoundexpressionconstraint()
                pass

            elif la_ == 2:
                self.state = 74
                self.subexpressionconstraint()
                pass


            self.state = 77
            self.ws()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundexpressionconstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def disjunctionexpressionconstraint(self):
            return self.getTypedRuleContext(ECLsubsetParser.DisjunctionexpressionconstraintContext,0)


        def exclusionexpressionconstraint(self):
            return self.getTypedRuleContext(ECLsubsetParser.ExclusionexpressionconstraintContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_compoundexpressionconstraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundexpressionconstraint" ):
                return visitor.visitCompoundexpressionconstraint(self)
            else:
                return visitor.visitChildren(self)




    def compoundexpressionconstraint(self):

        localctx = ECLsubsetParser.CompoundexpressionconstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_compoundexpressionconstraint)
        try:
            self.state = 81
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 79
                self.disjunctionexpressionconstraint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 80
                self.exclusionexpressionconstraint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisjunctionexpressionconstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subexpressionconstraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.SubexpressionconstraintContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.SubexpressionconstraintContext,i)


        def ws(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.WsContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.WsContext,i)


        def disjunction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.DisjunctionContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.DisjunctionContext,i)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_disjunctionexpressionconstraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisjunctionexpressionconstraint" ):
                return visitor.visitDisjunctionexpressionconstraint(self)
            else:
                return visitor.visitChildren(self)




    def disjunctionexpressionconstraint(self):

        localctx = ECLsubsetParser.DisjunctionexpressionconstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_disjunctionexpressionconstraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.subexpressionconstraint()
            self.state = 89 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 84
                    self.ws()
                    self.state = 85
                    self.disjunction()
                    self.state = 86
                    self.ws()
                    self.state = 87
                    self.subexpressionconstraint()

                else:
                    raise NoViableAltException(self)
                self.state = 91 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExclusionexpressionconstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subexpressionconstraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.SubexpressionconstraintContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.SubexpressionconstraintContext,i)


        def ws(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.WsContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.WsContext,i)


        def exclusion(self):
            return self.getTypedRuleContext(ECLsubsetParser.ExclusionContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_exclusionexpressionconstraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExclusionexpressionconstraint" ):
                return visitor.visitExclusionexpressionconstraint(self)
            else:
                return visitor.visitChildren(self)




    def exclusionexpressionconstraint(self):

        localctx = ECLsubsetParser.ExclusionexpressionconstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_exclusionexpressionconstraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.subexpressionconstraint()
            self.state = 94
            self.ws()
            self.state = 95
            self.exclusion()
            self.state = 96
            self.ws()
            self.state = 97
            self.subexpressionconstraint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubexpressionconstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eclfocusconcept(self):
            return self.getTypedRuleContext(ECLsubsetParser.EclfocusconceptContext,0)


        def constraintoperator(self):
            return self.getTypedRuleContext(ECLsubsetParser.ConstraintoperatorContext,0)


        def ws(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.WsContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.WsContext,i)


        def LEFT_PAREN(self):
            return self.getToken(ECLsubsetParser.LEFT_PAREN, 0)

        def expressionconstraint(self):
            return self.getTypedRuleContext(ECLsubsetParser.ExpressionconstraintContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(ECLsubsetParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_subexpressionconstraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubexpressionconstraint" ):
                return visitor.visitSubexpressionconstraint(self)
            else:
                return visitor.visitChildren(self)




    def subexpressionconstraint(self):

        localctx = ECLsubsetParser.SubexpressionconstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_subexpressionconstraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ECLsubsetParser.LESS_THAN or _la==ECLsubsetParser.GREATER_THAN:
                self.state = 99
                self.constraintoperator()
                self.state = 100
                self.ws()


            self.state = 111
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ECLsubsetParser.ONE, ECLsubsetParser.TWO, ECLsubsetParser.THREE, ECLsubsetParser.FOUR, ECLsubsetParser.FIVE, ECLsubsetParser.SIX, ECLsubsetParser.SEVEN, ECLsubsetParser.EIGHT, ECLsubsetParser.NINE]:
                self.state = 104
                self.eclfocusconcept()
                pass
            elif token in [ECLsubsetParser.LEFT_PAREN]:
                self.state = 105
                self.match(ECLsubsetParser.LEFT_PAREN)
                self.state = 106
                self.ws()
                self.state = 107
                self.expressionconstraint()
                self.state = 108
                self.ws()
                self.state = 109
                self.match(ECLsubsetParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EclfocusconceptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eclconceptreference(self):
            return self.getTypedRuleContext(ECLsubsetParser.EclconceptreferenceContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_eclfocusconcept

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEclfocusconcept" ):
                return visitor.visitEclfocusconcept(self)
            else:
                return visitor.visitChildren(self)




    def eclfocusconcept(self):

        localctx = ECLsubsetParser.EclfocusconceptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_eclfocusconcept)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.eclconceptreference()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EclconceptreferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conceptid(self):
            return self.getTypedRuleContext(ECLsubsetParser.ConceptidContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_eclconceptreference

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEclconceptreference" ):
                return visitor.visitEclconceptreference(self)
            else:
                return visitor.visitChildren(self)




    def eclconceptreference(self):

        localctx = ECLsubsetParser.EclconceptreferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_eclconceptreference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self.conceptid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConceptidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sctid(self):
            return self.getTypedRuleContext(ECLsubsetParser.SctidContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_conceptid

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConceptid" ):
                return visitor.visitConceptid(self)
            else:
                return visitor.visitChildren(self)




    def conceptid(self):

        localctx = ECLsubsetParser.ConceptidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_conceptid)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.sctid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintoperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def childof(self):
            return self.getTypedRuleContext(ECLsubsetParser.ChildofContext,0)


        def descendantorselfof(self):
            return self.getTypedRuleContext(ECLsubsetParser.DescendantorselfofContext,0)


        def descendantof(self):
            return self.getTypedRuleContext(ECLsubsetParser.DescendantofContext,0)


        def parentof(self):
            return self.getTypedRuleContext(ECLsubsetParser.ParentofContext,0)


        def ancestororselfof(self):
            return self.getTypedRuleContext(ECLsubsetParser.AncestororselfofContext,0)


        def ancestorof(self):
            return self.getTypedRuleContext(ECLsubsetParser.AncestorofContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_constraintoperator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintoperator" ):
                return visitor.visitConstraintoperator(self)
            else:
                return visitor.visitChildren(self)




    def constraintoperator(self):

        localctx = ECLsubsetParser.ConstraintoperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_constraintoperator)
        try:
            self.state = 125
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 119
                self.childof()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 120
                self.descendantorselfof()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 121
                self.descendantof()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 122
                self.parentof()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 123
                self.ancestororselfof()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 124
                self.ancestorof()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescendantofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LESS_THAN(self):
            return self.getToken(ECLsubsetParser.LESS_THAN, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_descendantof

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescendantof" ):
                return visitor.visitDescendantof(self)
            else:
                return visitor.visitChildren(self)




    def descendantof(self):

        localctx = ECLsubsetParser.DescendantofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_descendantof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(ECLsubsetParser.LESS_THAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescendantorselfofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LESS_THAN(self, i:int=None):
            if i is None:
                return self.getTokens(ECLsubsetParser.LESS_THAN)
            else:
                return self.getToken(ECLsubsetParser.LESS_THAN, i)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_descendantorselfof

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescendantorselfof" ):
                return visitor.visitDescendantorselfof(self)
            else:
                return visitor.visitChildren(self)




    def descendantorselfof(self):

        localctx = ECLsubsetParser.DescendantorselfofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_descendantorselfof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(ECLsubsetParser.LESS_THAN)
            self.state = 130
            self.match(ECLsubsetParser.LESS_THAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChildofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LESS_THAN(self):
            return self.getToken(ECLsubsetParser.LESS_THAN, 0)

        def EXCLAMATION(self):
            return self.getToken(ECLsubsetParser.EXCLAMATION, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_childof

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChildof" ):
                return visitor.visitChildof(self)
            else:
                return visitor.visitChildren(self)




    def childof(self):

        localctx = ECLsubsetParser.ChildofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_childof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(ECLsubsetParser.LESS_THAN)
            self.state = 133
            self.match(ECLsubsetParser.EXCLAMATION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AncestorofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GREATER_THAN(self):
            return self.getToken(ECLsubsetParser.GREATER_THAN, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_ancestorof

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAncestorof" ):
                return visitor.visitAncestorof(self)
            else:
                return visitor.visitChildren(self)




    def ancestorof(self):

        localctx = ECLsubsetParser.AncestorofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ancestorof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(ECLsubsetParser.GREATER_THAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AncestororselfofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GREATER_THAN(self, i:int=None):
            if i is None:
                return self.getTokens(ECLsubsetParser.GREATER_THAN)
            else:
                return self.getToken(ECLsubsetParser.GREATER_THAN, i)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_ancestororselfof

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAncestororselfof" ):
                return visitor.visitAncestororselfof(self)
            else:
                return visitor.visitChildren(self)




    def ancestororselfof(self):

        localctx = ECLsubsetParser.AncestororselfofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_ancestororselfof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(ECLsubsetParser.GREATER_THAN)
            self.state = 138
            self.match(ECLsubsetParser.GREATER_THAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParentofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GREATER_THAN(self):
            return self.getToken(ECLsubsetParser.GREATER_THAN, 0)

        def EXCLAMATION(self):
            return self.getToken(ECLsubsetParser.EXCLAMATION, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_parentof

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParentof" ):
                return visitor.visitParentof(self)
            else:
                return visitor.visitChildren(self)




    def parentof(self):

        localctx = ECLsubsetParser.ParentofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_parentof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(ECLsubsetParser.GREATER_THAN)
            self.state = 141
            self.match(ECLsubsetParser.EXCLAMATION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisjunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mws(self):
            return self.getTypedRuleContext(ECLsubsetParser.MwsContext,0)


        def O(self):
            return self.getToken(ECLsubsetParser.O, 0)

        def CAP_O(self):
            return self.getToken(ECLsubsetParser.CAP_O, 0)

        def R(self):
            return self.getToken(ECLsubsetParser.R, 0)

        def CAP_R(self):
            return self.getToken(ECLsubsetParser.CAP_R, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_disjunction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisjunction" ):
                return visitor.visitDisjunction(self)
            else:
                return visitor.visitChildren(self)




    def disjunction(self):

        localctx = ECLsubsetParser.DisjunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_disjunction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            _la = self._input.LA(1)
            if not(_la==ECLsubsetParser.CAP_O or _la==ECLsubsetParser.O):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 144
            _la = self._input.LA(1)
            if not(_la==ECLsubsetParser.CAP_R or _la==ECLsubsetParser.R):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 145
            self.mws()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mws(self):
            return self.getTypedRuleContext(ECLsubsetParser.MwsContext,0)


        def M(self):
            return self.getToken(ECLsubsetParser.M, 0)

        def CAP_M(self):
            return self.getToken(ECLsubsetParser.CAP_M, 0)

        def I(self):
            return self.getToken(ECLsubsetParser.I, 0)

        def CAP_I(self):
            return self.getToken(ECLsubsetParser.CAP_I, 0)

        def N(self):
            return self.getToken(ECLsubsetParser.N, 0)

        def CAP_N(self):
            return self.getToken(ECLsubsetParser.CAP_N, 0)

        def U(self):
            return self.getToken(ECLsubsetParser.U, 0)

        def CAP_U(self):
            return self.getToken(ECLsubsetParser.CAP_U, 0)

        def S(self):
            return self.getToken(ECLsubsetParser.S, 0)

        def CAP_S(self):
            return self.getToken(ECLsubsetParser.CAP_S, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_exclusion

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExclusion" ):
                return visitor.visitExclusion(self)
            else:
                return visitor.visitChildren(self)




    def exclusion(self):

        localctx = ECLsubsetParser.ExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_exclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            _la = self._input.LA(1)
            if not(_la==ECLsubsetParser.CAP_M or _la==ECLsubsetParser.M):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 148
            _la = self._input.LA(1)
            if not(_la==ECLsubsetParser.CAP_I or _la==ECLsubsetParser.I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 149
            _la = self._input.LA(1)
            if not(_la==ECLsubsetParser.CAP_N or _la==ECLsubsetParser.N):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 150
            _la = self._input.LA(1)
            if not(_la==ECLsubsetParser.CAP_U or _la==ECLsubsetParser.U):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 151
            _la = self._input.LA(1)
            if not(_la==ECLsubsetParser.CAP_S or _la==ECLsubsetParser.S):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 152
            self.mws()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SctidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digitnonzero(self):
            return self.getTypedRuleContext(ECLsubsetParser.DigitnonzeroContext,0)


        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.DigitContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.DigitContext,i)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_sctid

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSctid" ):
                return visitor.visitSctid(self)
            else:
                return visitor.visitChildren(self)




    def sctid(self):

        localctx = ECLsubsetParser.SctidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_sctid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.digitnonzero()

            self.state = 155
            self.digit()

            self.state = 156
            self.digit()

            self.state = 157
            self.digit()

            self.state = 158
            self.digit()

            self.state = 159
            self.digit()
            self.state = 251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 161
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.ZERO) | (1 << ECLsubsetParser.ONE) | (1 << ECLsubsetParser.TWO) | (1 << ECLsubsetParser.THREE) | (1 << ECLsubsetParser.FOUR) | (1 << ECLsubsetParser.FIVE) | (1 << ECLsubsetParser.SIX) | (1 << ECLsubsetParser.SEVEN) | (1 << ECLsubsetParser.EIGHT) | (1 << ECLsubsetParser.NINE))) != 0):
                    self.state = 160
                    self.digit()


                pass

            elif la_ == 2:
                self.state = 163
                self.digit()

                self.state = 164
                self.digit()
                pass

            elif la_ == 3:
                self.state = 166
                self.digit()

                self.state = 167
                self.digit()

                self.state = 168
                self.digit()
                pass

            elif la_ == 4:
                self.state = 170
                self.digit()

                self.state = 171
                self.digit()

                self.state = 172
                self.digit()

                self.state = 173
                self.digit()
                pass

            elif la_ == 5:
                self.state = 175
                self.digit()

                self.state = 176
                self.digit()

                self.state = 177
                self.digit()

                self.state = 178
                self.digit()

                self.state = 179
                self.digit()
                pass

            elif la_ == 6:
                self.state = 181
                self.digit()

                self.state = 182
                self.digit()

                self.state = 183
                self.digit()

                self.state = 184
                self.digit()

                self.state = 185
                self.digit()

                self.state = 186
                self.digit()
                pass

            elif la_ == 7:
                self.state = 188
                self.digit()

                self.state = 189
                self.digit()

                self.state = 190
                self.digit()

                self.state = 191
                self.digit()

                self.state = 192
                self.digit()

                self.state = 193
                self.digit()

                self.state = 194
                self.digit()
                pass

            elif la_ == 8:
                self.state = 196
                self.digit()

                self.state = 197
                self.digit()

                self.state = 198
                self.digit()

                self.state = 199
                self.digit()

                self.state = 200
                self.digit()

                self.state = 201
                self.digit()

                self.state = 202
                self.digit()

                self.state = 203
                self.digit()
                pass

            elif la_ == 9:
                self.state = 205
                self.digit()

                self.state = 206
                self.digit()

                self.state = 207
                self.digit()

                self.state = 208
                self.digit()

                self.state = 209
                self.digit()

                self.state = 210
                self.digit()

                self.state = 211
                self.digit()

                self.state = 212
                self.digit()

                self.state = 213
                self.digit()
                pass

            elif la_ == 10:
                self.state = 215
                self.digit()

                self.state = 216
                self.digit()

                self.state = 217
                self.digit()

                self.state = 218
                self.digit()

                self.state = 219
                self.digit()

                self.state = 220
                self.digit()

                self.state = 221
                self.digit()

                self.state = 222
                self.digit()

                self.state = 223
                self.digit()

                self.state = 224
                self.digit()
                pass

            elif la_ == 11:
                self.state = 226
                self.digit()

                self.state = 227
                self.digit()

                self.state = 228
                self.digit()

                self.state = 229
                self.digit()

                self.state = 230
                self.digit()

                self.state = 231
                self.digit()

                self.state = 232
                self.digit()

                self.state = 233
                self.digit()

                self.state = 234
                self.digit()

                self.state = 235
                self.digit()

                self.state = 236
                self.digit()
                pass

            elif la_ == 12:
                self.state = 238
                self.digit()

                self.state = 239
                self.digit()

                self.state = 240
                self.digit()

                self.state = 241
                self.digit()

                self.state = 242
                self.digit()

                self.state = 243
                self.digit()

                self.state = 244
                self.digit()

                self.state = 245
                self.digit()

                self.state = 246
                self.digit()

                self.state = 247
                self.digit()

                self.state = 248
                self.digit()

                self.state = 249
                self.digit()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.SpContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.SpContext,i)


        def htab(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.HtabContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.HtabContext,i)


        def cr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.CrContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.CrContext,i)


        def lf(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.LfContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.LfContext,i)


        def comment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.CommentContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.CommentContext,i)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_ws

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWs" ):
                return visitor.visitWs(self)
            else:
                return visitor.visitChildren(self)




    def ws(self):

        localctx = ECLsubsetParser.WsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_ws)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 258
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [ECLsubsetParser.SPACE]:
                        self.state = 253
                        self.sp()
                        pass
                    elif token in [ECLsubsetParser.TAB]:
                        self.state = 254
                        self.htab()
                        pass
                    elif token in [ECLsubsetParser.CR]:
                        self.state = 255
                        self.cr()
                        pass
                    elif token in [ECLsubsetParser.LF]:
                        self.state = 256
                        self.lf()
                        pass
                    elif token in [ECLsubsetParser.SLASH]:
                        self.state = 257
                        self.comment()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 262
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MwsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.SpContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.SpContext,i)


        def htab(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.HtabContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.HtabContext,i)


        def cr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.CrContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.CrContext,i)


        def lf(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.LfContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.LfContext,i)


        def comment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.CommentContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.CommentContext,i)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_mws

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMws" ):
                return visitor.visitMws(self)
            else:
                return visitor.visitChildren(self)




    def mws(self):

        localctx = ECLsubsetParser.MwsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_mws)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 268
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [ECLsubsetParser.SPACE]:
                        self.state = 263
                        self.sp()
                        pass
                    elif token in [ECLsubsetParser.TAB]:
                        self.state = 264
                        self.htab()
                        pass
                    elif token in [ECLsubsetParser.CR]:
                        self.state = 265
                        self.cr()
                        pass
                    elif token in [ECLsubsetParser.LF]:
                        self.state = 266
                        self.lf()
                        pass
                    elif token in [ECLsubsetParser.SLASH]:
                        self.state = 267
                        self.comment()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 270 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH(self, i:int=None):
            if i is None:
                return self.getTokens(ECLsubsetParser.SLASH)
            else:
                return self.getToken(ECLsubsetParser.SLASH, i)

        def ASTERISK(self, i:int=None):
            if i is None:
                return self.getTokens(ECLsubsetParser.ASTERISK)
            else:
                return self.getToken(ECLsubsetParser.ASTERISK, i)

        def nonstarchar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.NonstarcharContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.NonstarcharContext,i)


        def starwithnonfslash(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.StarwithnonfslashContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.StarwithnonfslashContext,i)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_comment

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComment" ):
                return visitor.visitComment(self)
            else:
                return visitor.visitChildren(self)




    def comment(self):

        localctx = ECLsubsetParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_comment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            self.match(ECLsubsetParser.SLASH)
            self.state = 273
            self.match(ECLsubsetParser.ASTERISK)
            self.state = 279
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 277
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [ECLsubsetParser.UTF8_LETTER, ECLsubsetParser.TAB, ECLsubsetParser.LF, ECLsubsetParser.CR, ECLsubsetParser.SPACE, ECLsubsetParser.EXCLAMATION, ECLsubsetParser.QUOTE, ECLsubsetParser.POUND, ECLsubsetParser.DOLLAR, ECLsubsetParser.PERCENT, ECLsubsetParser.AMPERSAND, ECLsubsetParser.APOSTROPHE, ECLsubsetParser.LEFT_PAREN, ECLsubsetParser.RIGHT_PAREN, ECLsubsetParser.PLUS, ECLsubsetParser.COMMA, ECLsubsetParser.DASH, ECLsubsetParser.PERIOD, ECLsubsetParser.SLASH, ECLsubsetParser.ZERO, ECLsubsetParser.ONE, ECLsubsetParser.TWO, ECLsubsetParser.THREE, ECLsubsetParser.FOUR, ECLsubsetParser.FIVE, ECLsubsetParser.SIX, ECLsubsetParser.SEVEN, ECLsubsetParser.EIGHT, ECLsubsetParser.NINE, ECLsubsetParser.COLON, ECLsubsetParser.SEMICOLON, ECLsubsetParser.LESS_THAN, ECLsubsetParser.EQUALS, ECLsubsetParser.GREATER_THAN, ECLsubsetParser.QUESTION, ECLsubsetParser.AT, ECLsubsetParser.CAP_A, ECLsubsetParser.CAP_B, ECLsubsetParser.CAP_C, ECLsubsetParser.CAP_D, ECLsubsetParser.CAP_E, ECLsubsetParser.CAP_F, ECLsubsetParser.CAP_G, ECLsubsetParser.CAP_H, ECLsubsetParser.CAP_I, ECLsubsetParser.CAP_J, ECLsubsetParser.CAP_K, ECLsubsetParser.CAP_L, ECLsubsetParser.CAP_M, ECLsubsetParser.CAP_N, ECLsubsetParser.CAP_O, ECLsubsetParser.CAP_P, ECLsubsetParser.CAP_Q, ECLsubsetParser.CAP_R, ECLsubsetParser.CAP_S, ECLsubsetParser.CAP_T, ECLsubsetParser.CAP_U, ECLsubsetParser.CAP_V, ECLsubsetParser.CAP_W, ECLsubsetParser.CAP_X, ECLsubsetParser.CAP_Y, ECLsubsetParser.CAP_Z, ECLsubsetParser.LEFT_BRACE, ECLsubsetParser.BACKSLASH, ECLsubsetParser.RIGHT_BRACE, ECLsubsetParser.CARAT, ECLsubsetParser.UNDERSCORE, ECLsubsetParser.ACCENT, ECLsubsetParser.A, ECLsubsetParser.B, ECLsubsetParser.C, ECLsubsetParser.D, ECLsubsetParser.E, ECLsubsetParser.F, ECLsubsetParser.G, ECLsubsetParser.H, ECLsubsetParser.I, ECLsubsetParser.J, ECLsubsetParser.K, ECLsubsetParser.L, ECLsubsetParser.M, ECLsubsetParser.N, ECLsubsetParser.O, ECLsubsetParser.P, ECLsubsetParser.Q, ECLsubsetParser.R, ECLsubsetParser.S, ECLsubsetParser.T, ECLsubsetParser.U, ECLsubsetParser.V, ECLsubsetParser.W, ECLsubsetParser.X, ECLsubsetParser.Y, ECLsubsetParser.Z, ECLsubsetParser.LEFT_CURLY_BRACE, ECLsubsetParser.PIPE, ECLsubsetParser.RIGHT_CURLY_BRACE, ECLsubsetParser.TILDE]:
                        self.state = 275
                        self.nonstarchar()
                        pass
                    elif token in [ECLsubsetParser.ASTERISK]:
                        self.state = 276
                        self.starwithnonfslash()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 281
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

            self.state = 282
            self.match(ECLsubsetParser.ASTERISK)
            self.state = 283
            self.match(ECLsubsetParser.SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NonstarcharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sp(self):
            return self.getTypedRuleContext(ECLsubsetParser.SpContext,0)


        def htab(self):
            return self.getTypedRuleContext(ECLsubsetParser.HtabContext,0)


        def cr(self):
            return self.getTypedRuleContext(ECLsubsetParser.CrContext,0)


        def lf(self):
            return self.getTypedRuleContext(ECLsubsetParser.LfContext,0)


        def EXCLAMATION(self):
            return self.getToken(ECLsubsetParser.EXCLAMATION, 0)

        def QUOTE(self):
            return self.getToken(ECLsubsetParser.QUOTE, 0)

        def POUND(self):
            return self.getToken(ECLsubsetParser.POUND, 0)

        def DOLLAR(self):
            return self.getToken(ECLsubsetParser.DOLLAR, 0)

        def PERCENT(self):
            return self.getToken(ECLsubsetParser.PERCENT, 0)

        def AMPERSAND(self):
            return self.getToken(ECLsubsetParser.AMPERSAND, 0)

        def APOSTROPHE(self):
            return self.getToken(ECLsubsetParser.APOSTROPHE, 0)

        def LEFT_PAREN(self):
            return self.getToken(ECLsubsetParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(ECLsubsetParser.RIGHT_PAREN, 0)

        def PLUS(self):
            return self.getToken(ECLsubsetParser.PLUS, 0)

        def COMMA(self):
            return self.getToken(ECLsubsetParser.COMMA, 0)

        def DASH(self):
            return self.getToken(ECLsubsetParser.DASH, 0)

        def PERIOD(self):
            return self.getToken(ECLsubsetParser.PERIOD, 0)

        def SLASH(self):
            return self.getToken(ECLsubsetParser.SLASH, 0)

        def ZERO(self):
            return self.getToken(ECLsubsetParser.ZERO, 0)

        def ONE(self):
            return self.getToken(ECLsubsetParser.ONE, 0)

        def TWO(self):
            return self.getToken(ECLsubsetParser.TWO, 0)

        def THREE(self):
            return self.getToken(ECLsubsetParser.THREE, 0)

        def FOUR(self):
            return self.getToken(ECLsubsetParser.FOUR, 0)

        def FIVE(self):
            return self.getToken(ECLsubsetParser.FIVE, 0)

        def SIX(self):
            return self.getToken(ECLsubsetParser.SIX, 0)

        def SEVEN(self):
            return self.getToken(ECLsubsetParser.SEVEN, 0)

        def EIGHT(self):
            return self.getToken(ECLsubsetParser.EIGHT, 0)

        def NINE(self):
            return self.getToken(ECLsubsetParser.NINE, 0)

        def COLON(self):
            return self.getToken(ECLsubsetParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(ECLsubsetParser.SEMICOLON, 0)

        def LESS_THAN(self):
            return self.getToken(ECLsubsetParser.LESS_THAN, 0)

        def EQUALS(self):
            return self.getToken(ECLsubsetParser.EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(ECLsubsetParser.GREATER_THAN, 0)

        def QUESTION(self):
            return self.getToken(ECLsubsetParser.QUESTION, 0)

        def AT(self):
            return self.getToken(ECLsubsetParser.AT, 0)

        def CAP_A(self):
            return self.getToken(ECLsubsetParser.CAP_A, 0)

        def CAP_B(self):
            return self.getToken(ECLsubsetParser.CAP_B, 0)

        def CAP_C(self):
            return self.getToken(ECLsubsetParser.CAP_C, 0)

        def CAP_D(self):
            return self.getToken(ECLsubsetParser.CAP_D, 0)

        def CAP_E(self):
            return self.getToken(ECLsubsetParser.CAP_E, 0)

        def CAP_F(self):
            return self.getToken(ECLsubsetParser.CAP_F, 0)

        def CAP_G(self):
            return self.getToken(ECLsubsetParser.CAP_G, 0)

        def CAP_H(self):
            return self.getToken(ECLsubsetParser.CAP_H, 0)

        def CAP_I(self):
            return self.getToken(ECLsubsetParser.CAP_I, 0)

        def CAP_J(self):
            return self.getToken(ECLsubsetParser.CAP_J, 0)

        def CAP_K(self):
            return self.getToken(ECLsubsetParser.CAP_K, 0)

        def CAP_L(self):
            return self.getToken(ECLsubsetParser.CAP_L, 0)

        def CAP_M(self):
            return self.getToken(ECLsubsetParser.CAP_M, 0)

        def CAP_N(self):
            return self.getToken(ECLsubsetParser.CAP_N, 0)

        def CAP_O(self):
            return self.getToken(ECLsubsetParser.CAP_O, 0)

        def CAP_P(self):
            return self.getToken(ECLsubsetParser.CAP_P, 0)

        def CAP_Q(self):
            return self.getToken(ECLsubsetParser.CAP_Q, 0)

        def CAP_R(self):
            return self.getToken(ECLsubsetParser.CAP_R, 0)

        def CAP_S(self):
            return self.getToken(ECLsubsetParser.CAP_S, 0)

        def CAP_T(self):
            return self.getToken(ECLsubsetParser.CAP_T, 0)

        def CAP_U(self):
            return self.getToken(ECLsubsetParser.CAP_U, 0)

        def CAP_V(self):
            return self.getToken(ECLsubsetParser.CAP_V, 0)

        def CAP_W(self):
            return self.getToken(ECLsubsetParser.CAP_W, 0)

        def CAP_X(self):
            return self.getToken(ECLsubsetParser.CAP_X, 0)

        def CAP_Y(self):
            return self.getToken(ECLsubsetParser.CAP_Y, 0)

        def CAP_Z(self):
            return self.getToken(ECLsubsetParser.CAP_Z, 0)

        def LEFT_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_BRACE, 0)

        def BACKSLASH(self):
            return self.getToken(ECLsubsetParser.BACKSLASH, 0)

        def RIGHT_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_BRACE, 0)

        def CARAT(self):
            return self.getToken(ECLsubsetParser.CARAT, 0)

        def UNDERSCORE(self):
            return self.getToken(ECLsubsetParser.UNDERSCORE, 0)

        def ACCENT(self):
            return self.getToken(ECLsubsetParser.ACCENT, 0)

        def A(self):
            return self.getToken(ECLsubsetParser.A, 0)

        def B(self):
            return self.getToken(ECLsubsetParser.B, 0)

        def C(self):
            return self.getToken(ECLsubsetParser.C, 0)

        def D(self):
            return self.getToken(ECLsubsetParser.D, 0)

        def E(self):
            return self.getToken(ECLsubsetParser.E, 0)

        def F(self):
            return self.getToken(ECLsubsetParser.F, 0)

        def G(self):
            return self.getToken(ECLsubsetParser.G, 0)

        def H(self):
            return self.getToken(ECLsubsetParser.H, 0)

        def I(self):
            return self.getToken(ECLsubsetParser.I, 0)

        def J(self):
            return self.getToken(ECLsubsetParser.J, 0)

        def K(self):
            return self.getToken(ECLsubsetParser.K, 0)

        def L(self):
            return self.getToken(ECLsubsetParser.L, 0)

        def M(self):
            return self.getToken(ECLsubsetParser.M, 0)

        def N(self):
            return self.getToken(ECLsubsetParser.N, 0)

        def O(self):
            return self.getToken(ECLsubsetParser.O, 0)

        def P(self):
            return self.getToken(ECLsubsetParser.P, 0)

        def Q(self):
            return self.getToken(ECLsubsetParser.Q, 0)

        def R(self):
            return self.getToken(ECLsubsetParser.R, 0)

        def S(self):
            return self.getToken(ECLsubsetParser.S, 0)

        def T(self):
            return self.getToken(ECLsubsetParser.T, 0)

        def U(self):
            return self.getToken(ECLsubsetParser.U, 0)

        def V(self):
            return self.getToken(ECLsubsetParser.V, 0)

        def W(self):
            return self.getToken(ECLsubsetParser.W, 0)

        def X(self):
            return self.getToken(ECLsubsetParser.X, 0)

        def Y(self):
            return self.getToken(ECLsubsetParser.Y, 0)

        def Z(self):
            return self.getToken(ECLsubsetParser.Z, 0)

        def LEFT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_CURLY_BRACE, 0)

        def PIPE(self):
            return self.getToken(ECLsubsetParser.PIPE, 0)

        def RIGHT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_CURLY_BRACE, 0)

        def TILDE(self):
            return self.getToken(ECLsubsetParser.TILDE, 0)

        def UTF8_LETTER(self):
            return self.getToken(ECLsubsetParser.UTF8_LETTER, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_nonstarchar

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNonstarchar" ):
                return visitor.visitNonstarchar(self)
            else:
                return visitor.visitChildren(self)




    def nonstarchar(self):

        localctx = ECLsubsetParser.NonstarcharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_nonstarchar)
        self._la = 0 # Token type
        try:
            self.state = 292
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ECLsubsetParser.SPACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 285
                self.sp()
                pass
            elif token in [ECLsubsetParser.TAB]:
                self.enterOuterAlt(localctx, 2)
                self.state = 286
                self.htab()
                pass
            elif token in [ECLsubsetParser.CR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 287
                self.cr()
                pass
            elif token in [ECLsubsetParser.LF]:
                self.enterOuterAlt(localctx, 4)
                self.state = 288
                self.lf()
                pass
            elif token in [ECLsubsetParser.EXCLAMATION, ECLsubsetParser.QUOTE, ECLsubsetParser.POUND, ECLsubsetParser.DOLLAR, ECLsubsetParser.PERCENT, ECLsubsetParser.AMPERSAND, ECLsubsetParser.APOSTROPHE, ECLsubsetParser.LEFT_PAREN, ECLsubsetParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 5)
                self.state = 289
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.EXCLAMATION) | (1 << ECLsubsetParser.QUOTE) | (1 << ECLsubsetParser.POUND) | (1 << ECLsubsetParser.DOLLAR) | (1 << ECLsubsetParser.PERCENT) | (1 << ECLsubsetParser.AMPERSAND) | (1 << ECLsubsetParser.APOSTROPHE) | (1 << ECLsubsetParser.LEFT_PAREN) | (1 << ECLsubsetParser.RIGHT_PAREN))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ECLsubsetParser.PLUS, ECLsubsetParser.COMMA, ECLsubsetParser.DASH, ECLsubsetParser.PERIOD, ECLsubsetParser.SLASH, ECLsubsetParser.ZERO, ECLsubsetParser.ONE, ECLsubsetParser.TWO, ECLsubsetParser.THREE, ECLsubsetParser.FOUR, ECLsubsetParser.FIVE, ECLsubsetParser.SIX, ECLsubsetParser.SEVEN, ECLsubsetParser.EIGHT, ECLsubsetParser.NINE, ECLsubsetParser.COLON, ECLsubsetParser.SEMICOLON, ECLsubsetParser.LESS_THAN, ECLsubsetParser.EQUALS, ECLsubsetParser.GREATER_THAN, ECLsubsetParser.QUESTION, ECLsubsetParser.AT, ECLsubsetParser.CAP_A, ECLsubsetParser.CAP_B, ECLsubsetParser.CAP_C, ECLsubsetParser.CAP_D, ECLsubsetParser.CAP_E, ECLsubsetParser.CAP_F, ECLsubsetParser.CAP_G, ECLsubsetParser.CAP_H, ECLsubsetParser.CAP_I, ECLsubsetParser.CAP_J, ECLsubsetParser.CAP_K, ECLsubsetParser.CAP_L, ECLsubsetParser.CAP_M, ECLsubsetParser.CAP_N, ECLsubsetParser.CAP_O, ECLsubsetParser.CAP_P, ECLsubsetParser.CAP_Q, ECLsubsetParser.CAP_R, ECLsubsetParser.CAP_S, ECLsubsetParser.CAP_T, ECLsubsetParser.CAP_U, ECLsubsetParser.CAP_V, ECLsubsetParser.CAP_W, ECLsubsetParser.CAP_X, ECLsubsetParser.CAP_Y, ECLsubsetParser.CAP_Z, ECLsubsetParser.LEFT_BRACE, ECLsubsetParser.BACKSLASH, ECLsubsetParser.RIGHT_BRACE, ECLsubsetParser.CARAT, ECLsubsetParser.UNDERSCORE, ECLsubsetParser.ACCENT, ECLsubsetParser.A, ECLsubsetParser.B, ECLsubsetParser.C, ECLsubsetParser.D, ECLsubsetParser.E, ECLsubsetParser.F, ECLsubsetParser.G, ECLsubsetParser.H, ECLsubsetParser.I, ECLsubsetParser.J, ECLsubsetParser.K, ECLsubsetParser.L, ECLsubsetParser.M, ECLsubsetParser.N, ECLsubsetParser.O, ECLsubsetParser.P, ECLsubsetParser.Q, ECLsubsetParser.R, ECLsubsetParser.S, ECLsubsetParser.T, ECLsubsetParser.U, ECLsubsetParser.V, ECLsubsetParser.W, ECLsubsetParser.X, ECLsubsetParser.Y, ECLsubsetParser.Z, ECLsubsetParser.LEFT_CURLY_BRACE, ECLsubsetParser.PIPE, ECLsubsetParser.RIGHT_CURLY_BRACE, ECLsubsetParser.TILDE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 290
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.PLUS) | (1 << ECLsubsetParser.COMMA) | (1 << ECLsubsetParser.DASH) | (1 << ECLsubsetParser.PERIOD) | (1 << ECLsubsetParser.SLASH) | (1 << ECLsubsetParser.ZERO) | (1 << ECLsubsetParser.ONE) | (1 << ECLsubsetParser.TWO) | (1 << ECLsubsetParser.THREE) | (1 << ECLsubsetParser.FOUR) | (1 << ECLsubsetParser.FIVE) | (1 << ECLsubsetParser.SIX) | (1 << ECLsubsetParser.SEVEN) | (1 << ECLsubsetParser.EIGHT) | (1 << ECLsubsetParser.NINE) | (1 << ECLsubsetParser.COLON) | (1 << ECLsubsetParser.SEMICOLON) | (1 << ECLsubsetParser.LESS_THAN) | (1 << ECLsubsetParser.EQUALS) | (1 << ECLsubsetParser.GREATER_THAN) | (1 << ECLsubsetParser.QUESTION) | (1 << ECLsubsetParser.AT) | (1 << ECLsubsetParser.CAP_A) | (1 << ECLsubsetParser.CAP_B) | (1 << ECLsubsetParser.CAP_C) | (1 << ECLsubsetParser.CAP_D) | (1 << ECLsubsetParser.CAP_E) | (1 << ECLsubsetParser.CAP_F) | (1 << ECLsubsetParser.CAP_G) | (1 << ECLsubsetParser.CAP_H) | (1 << ECLsubsetParser.CAP_I) | (1 << ECLsubsetParser.CAP_J) | (1 << ECLsubsetParser.CAP_K) | (1 << ECLsubsetParser.CAP_L) | (1 << ECLsubsetParser.CAP_M) | (1 << ECLsubsetParser.CAP_N) | (1 << ECLsubsetParser.CAP_O) | (1 << ECLsubsetParser.CAP_P) | (1 << ECLsubsetParser.CAP_Q) | (1 << ECLsubsetParser.CAP_R) | (1 << ECLsubsetParser.CAP_S) | (1 << ECLsubsetParser.CAP_T) | (1 << ECLsubsetParser.CAP_U) | (1 << ECLsubsetParser.CAP_V) | (1 << ECLsubsetParser.CAP_W) | (1 << ECLsubsetParser.CAP_X) | (1 << ECLsubsetParser.CAP_Y) | (1 << ECLsubsetParser.CAP_Z))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ECLsubsetParser.LEFT_BRACE - 64)) | (1 << (ECLsubsetParser.BACKSLASH - 64)) | (1 << (ECLsubsetParser.RIGHT_BRACE - 64)) | (1 << (ECLsubsetParser.CARAT - 64)) | (1 << (ECLsubsetParser.UNDERSCORE - 64)) | (1 << (ECLsubsetParser.ACCENT - 64)) | (1 << (ECLsubsetParser.A - 64)) | (1 << (ECLsubsetParser.B - 64)) | (1 << (ECLsubsetParser.C - 64)) | (1 << (ECLsubsetParser.D - 64)) | (1 << (ECLsubsetParser.E - 64)) | (1 << (ECLsubsetParser.F - 64)) | (1 << (ECLsubsetParser.G - 64)) | (1 << (ECLsubsetParser.H - 64)) | (1 << (ECLsubsetParser.I - 64)) | (1 << (ECLsubsetParser.J - 64)) | (1 << (ECLsubsetParser.K - 64)) | (1 << (ECLsubsetParser.L - 64)) | (1 << (ECLsubsetParser.M - 64)) | (1 << (ECLsubsetParser.N - 64)) | (1 << (ECLsubsetParser.O - 64)) | (1 << (ECLsubsetParser.P - 64)) | (1 << (ECLsubsetParser.Q - 64)) | (1 << (ECLsubsetParser.R - 64)) | (1 << (ECLsubsetParser.S - 64)) | (1 << (ECLsubsetParser.T - 64)) | (1 << (ECLsubsetParser.U - 64)) | (1 << (ECLsubsetParser.V - 64)) | (1 << (ECLsubsetParser.W - 64)) | (1 << (ECLsubsetParser.X - 64)) | (1 << (ECLsubsetParser.Y - 64)) | (1 << (ECLsubsetParser.Z - 64)) | (1 << (ECLsubsetParser.LEFT_CURLY_BRACE - 64)) | (1 << (ECLsubsetParser.PIPE - 64)) | (1 << (ECLsubsetParser.RIGHT_CURLY_BRACE - 64)) | (1 << (ECLsubsetParser.TILDE - 64)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ECLsubsetParser.UTF8_LETTER]:
                self.enterOuterAlt(localctx, 7)
                self.state = 291
                self.match(ECLsubsetParser.UTF8_LETTER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StarwithnonfslashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(ECLsubsetParser.ASTERISK, 0)

        def nonfslash(self):
            return self.getTypedRuleContext(ECLsubsetParser.NonfslashContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_starwithnonfslash

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStarwithnonfslash" ):
                return visitor.visitStarwithnonfslash(self)
            else:
                return visitor.visitChildren(self)




    def starwithnonfslash(self):

        localctx = ECLsubsetParser.StarwithnonfslashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_starwithnonfslash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(ECLsubsetParser.ASTERISK)
            self.state = 295
            self.nonfslash()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NonfslashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sp(self):
            return self.getTypedRuleContext(ECLsubsetParser.SpContext,0)


        def htab(self):
            return self.getTypedRuleContext(ECLsubsetParser.HtabContext,0)


        def cr(self):
            return self.getTypedRuleContext(ECLsubsetParser.CrContext,0)


        def lf(self):
            return self.getTypedRuleContext(ECLsubsetParser.LfContext,0)


        def EXCLAMATION(self):
            return self.getToken(ECLsubsetParser.EXCLAMATION, 0)

        def QUOTE(self):
            return self.getToken(ECLsubsetParser.QUOTE, 0)

        def POUND(self):
            return self.getToken(ECLsubsetParser.POUND, 0)

        def DOLLAR(self):
            return self.getToken(ECLsubsetParser.DOLLAR, 0)

        def PERCENT(self):
            return self.getToken(ECLsubsetParser.PERCENT, 0)

        def AMPERSAND(self):
            return self.getToken(ECLsubsetParser.AMPERSAND, 0)

        def APOSTROPHE(self):
            return self.getToken(ECLsubsetParser.APOSTROPHE, 0)

        def LEFT_PAREN(self):
            return self.getToken(ECLsubsetParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(ECLsubsetParser.RIGHT_PAREN, 0)

        def ASTERISK(self):
            return self.getToken(ECLsubsetParser.ASTERISK, 0)

        def PLUS(self):
            return self.getToken(ECLsubsetParser.PLUS, 0)

        def COMMA(self):
            return self.getToken(ECLsubsetParser.COMMA, 0)

        def DASH(self):
            return self.getToken(ECLsubsetParser.DASH, 0)

        def PERIOD(self):
            return self.getToken(ECLsubsetParser.PERIOD, 0)

        def ZERO(self):
            return self.getToken(ECLsubsetParser.ZERO, 0)

        def ONE(self):
            return self.getToken(ECLsubsetParser.ONE, 0)

        def TWO(self):
            return self.getToken(ECLsubsetParser.TWO, 0)

        def THREE(self):
            return self.getToken(ECLsubsetParser.THREE, 0)

        def FOUR(self):
            return self.getToken(ECLsubsetParser.FOUR, 0)

        def FIVE(self):
            return self.getToken(ECLsubsetParser.FIVE, 0)

        def SIX(self):
            return self.getToken(ECLsubsetParser.SIX, 0)

        def SEVEN(self):
            return self.getToken(ECLsubsetParser.SEVEN, 0)

        def EIGHT(self):
            return self.getToken(ECLsubsetParser.EIGHT, 0)

        def NINE(self):
            return self.getToken(ECLsubsetParser.NINE, 0)

        def COLON(self):
            return self.getToken(ECLsubsetParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(ECLsubsetParser.SEMICOLON, 0)

        def LESS_THAN(self):
            return self.getToken(ECLsubsetParser.LESS_THAN, 0)

        def EQUALS(self):
            return self.getToken(ECLsubsetParser.EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(ECLsubsetParser.GREATER_THAN, 0)

        def QUESTION(self):
            return self.getToken(ECLsubsetParser.QUESTION, 0)

        def AT(self):
            return self.getToken(ECLsubsetParser.AT, 0)

        def CAP_A(self):
            return self.getToken(ECLsubsetParser.CAP_A, 0)

        def CAP_B(self):
            return self.getToken(ECLsubsetParser.CAP_B, 0)

        def CAP_C(self):
            return self.getToken(ECLsubsetParser.CAP_C, 0)

        def CAP_D(self):
            return self.getToken(ECLsubsetParser.CAP_D, 0)

        def CAP_E(self):
            return self.getToken(ECLsubsetParser.CAP_E, 0)

        def CAP_F(self):
            return self.getToken(ECLsubsetParser.CAP_F, 0)

        def CAP_G(self):
            return self.getToken(ECLsubsetParser.CAP_G, 0)

        def CAP_H(self):
            return self.getToken(ECLsubsetParser.CAP_H, 0)

        def CAP_I(self):
            return self.getToken(ECLsubsetParser.CAP_I, 0)

        def CAP_J(self):
            return self.getToken(ECLsubsetParser.CAP_J, 0)

        def CAP_K(self):
            return self.getToken(ECLsubsetParser.CAP_K, 0)

        def CAP_L(self):
            return self.getToken(ECLsubsetParser.CAP_L, 0)

        def CAP_M(self):
            return self.getToken(ECLsubsetParser.CAP_M, 0)

        def CAP_N(self):
            return self.getToken(ECLsubsetParser.CAP_N, 0)

        def CAP_O(self):
            return self.getToken(ECLsubsetParser.CAP_O, 0)

        def CAP_P(self):
            return self.getToken(ECLsubsetParser.CAP_P, 0)

        def CAP_Q(self):
            return self.getToken(ECLsubsetParser.CAP_Q, 0)

        def CAP_R(self):
            return self.getToken(ECLsubsetParser.CAP_R, 0)

        def CAP_S(self):
            return self.getToken(ECLsubsetParser.CAP_S, 0)

        def CAP_T(self):
            return self.getToken(ECLsubsetParser.CAP_T, 0)

        def CAP_U(self):
            return self.getToken(ECLsubsetParser.CAP_U, 0)

        def CAP_V(self):
            return self.getToken(ECLsubsetParser.CAP_V, 0)

        def CAP_W(self):
            return self.getToken(ECLsubsetParser.CAP_W, 0)

        def CAP_X(self):
            return self.getToken(ECLsubsetParser.CAP_X, 0)

        def CAP_Y(self):
            return self.getToken(ECLsubsetParser.CAP_Y, 0)

        def CAP_Z(self):
            return self.getToken(ECLsubsetParser.CAP_Z, 0)

        def LEFT_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_BRACE, 0)

        def BACKSLASH(self):
            return self.getToken(ECLsubsetParser.BACKSLASH, 0)

        def RIGHT_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_BRACE, 0)

        def CARAT(self):
            return self.getToken(ECLsubsetParser.CARAT, 0)

        def UNDERSCORE(self):
            return self.getToken(ECLsubsetParser.UNDERSCORE, 0)

        def ACCENT(self):
            return self.getToken(ECLsubsetParser.ACCENT, 0)

        def A(self):
            return self.getToken(ECLsubsetParser.A, 0)

        def B(self):
            return self.getToken(ECLsubsetParser.B, 0)

        def C(self):
            return self.getToken(ECLsubsetParser.C, 0)

        def D(self):
            return self.getToken(ECLsubsetParser.D, 0)

        def E(self):
            return self.getToken(ECLsubsetParser.E, 0)

        def F(self):
            return self.getToken(ECLsubsetParser.F, 0)

        def G(self):
            return self.getToken(ECLsubsetParser.G, 0)

        def H(self):
            return self.getToken(ECLsubsetParser.H, 0)

        def I(self):
            return self.getToken(ECLsubsetParser.I, 0)

        def J(self):
            return self.getToken(ECLsubsetParser.J, 0)

        def K(self):
            return self.getToken(ECLsubsetParser.K, 0)

        def L(self):
            return self.getToken(ECLsubsetParser.L, 0)

        def M(self):
            return self.getToken(ECLsubsetParser.M, 0)

        def N(self):
            return self.getToken(ECLsubsetParser.N, 0)

        def O(self):
            return self.getToken(ECLsubsetParser.O, 0)

        def P(self):
            return self.getToken(ECLsubsetParser.P, 0)

        def Q(self):
            return self.getToken(ECLsubsetParser.Q, 0)

        def R(self):
            return self.getToken(ECLsubsetParser.R, 0)

        def S(self):
            return self.getToken(ECLsubsetParser.S, 0)

        def T(self):
            return self.getToken(ECLsubsetParser.T, 0)

        def U(self):
            return self.getToken(ECLsubsetParser.U, 0)

        def V(self):
            return self.getToken(ECLsubsetParser.V, 0)

        def W(self):
            return self.getToken(ECLsubsetParser.W, 0)

        def X(self):
            return self.getToken(ECLsubsetParser.X, 0)

        def Y(self):
            return self.getToken(ECLsubsetParser.Y, 0)

        def Z(self):
            return self.getToken(ECLsubsetParser.Z, 0)

        def LEFT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_CURLY_BRACE, 0)

        def PIPE(self):
            return self.getToken(ECLsubsetParser.PIPE, 0)

        def RIGHT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_CURLY_BRACE, 0)

        def TILDE(self):
            return self.getToken(ECLsubsetParser.TILDE, 0)

        def UTF8_LETTER(self):
            return self.getToken(ECLsubsetParser.UTF8_LETTER, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_nonfslash

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNonfslash" ):
                return visitor.visitNonfslash(self)
            else:
                return visitor.visitChildren(self)




    def nonfslash(self):

        localctx = ECLsubsetParser.NonfslashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_nonfslash)
        self._la = 0 # Token type
        try:
            self.state = 304
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ECLsubsetParser.SPACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 297
                self.sp()
                pass
            elif token in [ECLsubsetParser.TAB]:
                self.enterOuterAlt(localctx, 2)
                self.state = 298
                self.htab()
                pass
            elif token in [ECLsubsetParser.CR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 299
                self.cr()
                pass
            elif token in [ECLsubsetParser.LF]:
                self.enterOuterAlt(localctx, 4)
                self.state = 300
                self.lf()
                pass
            elif token in [ECLsubsetParser.EXCLAMATION, ECLsubsetParser.QUOTE, ECLsubsetParser.POUND, ECLsubsetParser.DOLLAR, ECLsubsetParser.PERCENT, ECLsubsetParser.AMPERSAND, ECLsubsetParser.APOSTROPHE, ECLsubsetParser.LEFT_PAREN, ECLsubsetParser.RIGHT_PAREN, ECLsubsetParser.ASTERISK, ECLsubsetParser.PLUS, ECLsubsetParser.COMMA, ECLsubsetParser.DASH, ECLsubsetParser.PERIOD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 301
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.EXCLAMATION) | (1 << ECLsubsetParser.QUOTE) | (1 << ECLsubsetParser.POUND) | (1 << ECLsubsetParser.DOLLAR) | (1 << ECLsubsetParser.PERCENT) | (1 << ECLsubsetParser.AMPERSAND) | (1 << ECLsubsetParser.APOSTROPHE) | (1 << ECLsubsetParser.LEFT_PAREN) | (1 << ECLsubsetParser.RIGHT_PAREN) | (1 << ECLsubsetParser.ASTERISK) | (1 << ECLsubsetParser.PLUS) | (1 << ECLsubsetParser.COMMA) | (1 << ECLsubsetParser.DASH) | (1 << ECLsubsetParser.PERIOD))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ECLsubsetParser.ZERO, ECLsubsetParser.ONE, ECLsubsetParser.TWO, ECLsubsetParser.THREE, ECLsubsetParser.FOUR, ECLsubsetParser.FIVE, ECLsubsetParser.SIX, ECLsubsetParser.SEVEN, ECLsubsetParser.EIGHT, ECLsubsetParser.NINE, ECLsubsetParser.COLON, ECLsubsetParser.SEMICOLON, ECLsubsetParser.LESS_THAN, ECLsubsetParser.EQUALS, ECLsubsetParser.GREATER_THAN, ECLsubsetParser.QUESTION, ECLsubsetParser.AT, ECLsubsetParser.CAP_A, ECLsubsetParser.CAP_B, ECLsubsetParser.CAP_C, ECLsubsetParser.CAP_D, ECLsubsetParser.CAP_E, ECLsubsetParser.CAP_F, ECLsubsetParser.CAP_G, ECLsubsetParser.CAP_H, ECLsubsetParser.CAP_I, ECLsubsetParser.CAP_J, ECLsubsetParser.CAP_K, ECLsubsetParser.CAP_L, ECLsubsetParser.CAP_M, ECLsubsetParser.CAP_N, ECLsubsetParser.CAP_O, ECLsubsetParser.CAP_P, ECLsubsetParser.CAP_Q, ECLsubsetParser.CAP_R, ECLsubsetParser.CAP_S, ECLsubsetParser.CAP_T, ECLsubsetParser.CAP_U, ECLsubsetParser.CAP_V, ECLsubsetParser.CAP_W, ECLsubsetParser.CAP_X, ECLsubsetParser.CAP_Y, ECLsubsetParser.CAP_Z, ECLsubsetParser.LEFT_BRACE, ECLsubsetParser.BACKSLASH, ECLsubsetParser.RIGHT_BRACE, ECLsubsetParser.CARAT, ECLsubsetParser.UNDERSCORE, ECLsubsetParser.ACCENT, ECLsubsetParser.A, ECLsubsetParser.B, ECLsubsetParser.C, ECLsubsetParser.D, ECLsubsetParser.E, ECLsubsetParser.F, ECLsubsetParser.G, ECLsubsetParser.H, ECLsubsetParser.I, ECLsubsetParser.J, ECLsubsetParser.K, ECLsubsetParser.L, ECLsubsetParser.M, ECLsubsetParser.N, ECLsubsetParser.O, ECLsubsetParser.P, ECLsubsetParser.Q, ECLsubsetParser.R, ECLsubsetParser.S, ECLsubsetParser.T, ECLsubsetParser.U, ECLsubsetParser.V, ECLsubsetParser.W, ECLsubsetParser.X, ECLsubsetParser.Y, ECLsubsetParser.Z, ECLsubsetParser.LEFT_CURLY_BRACE, ECLsubsetParser.PIPE, ECLsubsetParser.RIGHT_CURLY_BRACE, ECLsubsetParser.TILDE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 302
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.ZERO) | (1 << ECLsubsetParser.ONE) | (1 << ECLsubsetParser.TWO) | (1 << ECLsubsetParser.THREE) | (1 << ECLsubsetParser.FOUR) | (1 << ECLsubsetParser.FIVE) | (1 << ECLsubsetParser.SIX) | (1 << ECLsubsetParser.SEVEN) | (1 << ECLsubsetParser.EIGHT) | (1 << ECLsubsetParser.NINE) | (1 << ECLsubsetParser.COLON) | (1 << ECLsubsetParser.SEMICOLON) | (1 << ECLsubsetParser.LESS_THAN) | (1 << ECLsubsetParser.EQUALS) | (1 << ECLsubsetParser.GREATER_THAN) | (1 << ECLsubsetParser.QUESTION) | (1 << ECLsubsetParser.AT) | (1 << ECLsubsetParser.CAP_A) | (1 << ECLsubsetParser.CAP_B) | (1 << ECLsubsetParser.CAP_C) | (1 << ECLsubsetParser.CAP_D) | (1 << ECLsubsetParser.CAP_E) | (1 << ECLsubsetParser.CAP_F) | (1 << ECLsubsetParser.CAP_G) | (1 << ECLsubsetParser.CAP_H) | (1 << ECLsubsetParser.CAP_I) | (1 << ECLsubsetParser.CAP_J) | (1 << ECLsubsetParser.CAP_K) | (1 << ECLsubsetParser.CAP_L) | (1 << ECLsubsetParser.CAP_M) | (1 << ECLsubsetParser.CAP_N) | (1 << ECLsubsetParser.CAP_O) | (1 << ECLsubsetParser.CAP_P) | (1 << ECLsubsetParser.CAP_Q) | (1 << ECLsubsetParser.CAP_R) | (1 << ECLsubsetParser.CAP_S) | (1 << ECLsubsetParser.CAP_T) | (1 << ECLsubsetParser.CAP_U) | (1 << ECLsubsetParser.CAP_V) | (1 << ECLsubsetParser.CAP_W) | (1 << ECLsubsetParser.CAP_X) | (1 << ECLsubsetParser.CAP_Y) | (1 << ECLsubsetParser.CAP_Z))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ECLsubsetParser.LEFT_BRACE - 64)) | (1 << (ECLsubsetParser.BACKSLASH - 64)) | (1 << (ECLsubsetParser.RIGHT_BRACE - 64)) | (1 << (ECLsubsetParser.CARAT - 64)) | (1 << (ECLsubsetParser.UNDERSCORE - 64)) | (1 << (ECLsubsetParser.ACCENT - 64)) | (1 << (ECLsubsetParser.A - 64)) | (1 << (ECLsubsetParser.B - 64)) | (1 << (ECLsubsetParser.C - 64)) | (1 << (ECLsubsetParser.D - 64)) | (1 << (ECLsubsetParser.E - 64)) | (1 << (ECLsubsetParser.F - 64)) | (1 << (ECLsubsetParser.G - 64)) | (1 << (ECLsubsetParser.H - 64)) | (1 << (ECLsubsetParser.I - 64)) | (1 << (ECLsubsetParser.J - 64)) | (1 << (ECLsubsetParser.K - 64)) | (1 << (ECLsubsetParser.L - 64)) | (1 << (ECLsubsetParser.M - 64)) | (1 << (ECLsubsetParser.N - 64)) | (1 << (ECLsubsetParser.O - 64)) | (1 << (ECLsubsetParser.P - 64)) | (1 << (ECLsubsetParser.Q - 64)) | (1 << (ECLsubsetParser.R - 64)) | (1 << (ECLsubsetParser.S - 64)) | (1 << (ECLsubsetParser.T - 64)) | (1 << (ECLsubsetParser.U - 64)) | (1 << (ECLsubsetParser.V - 64)) | (1 << (ECLsubsetParser.W - 64)) | (1 << (ECLsubsetParser.X - 64)) | (1 << (ECLsubsetParser.Y - 64)) | (1 << (ECLsubsetParser.Z - 64)) | (1 << (ECLsubsetParser.LEFT_CURLY_BRACE - 64)) | (1 << (ECLsubsetParser.PIPE - 64)) | (1 << (ECLsubsetParser.RIGHT_CURLY_BRACE - 64)) | (1 << (ECLsubsetParser.TILDE - 64)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ECLsubsetParser.UTF8_LETTER]:
                self.enterOuterAlt(localctx, 7)
                self.state = 303
                self.match(ECLsubsetParser.UTF8_LETTER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SPACE(self):
            return self.getToken(ECLsubsetParser.SPACE, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_sp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSp" ):
                return visitor.visitSp(self)
            else:
                return visitor.visitChildren(self)




    def sp(self):

        localctx = ECLsubsetParser.SpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_sp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.match(ECLsubsetParser.SPACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HtabContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TAB(self):
            return self.getToken(ECLsubsetParser.TAB, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_htab

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHtab" ):
                return visitor.visitHtab(self)
            else:
                return visitor.visitChildren(self)




    def htab(self):

        localctx = ECLsubsetParser.HtabContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_htab)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 308
            self.match(ECLsubsetParser.TAB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CR(self):
            return self.getToken(ECLsubsetParser.CR, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_cr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCr" ):
                return visitor.visitCr(self)
            else:
                return visitor.visitChildren(self)




    def cr(self):

        localctx = ECLsubsetParser.CrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_cr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.match(ECLsubsetParser.CR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LF(self):
            return self.getToken(ECLsubsetParser.LF, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_lf

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLf" ):
                return visitor.visitLf(self)
            else:
                return visitor.visitChildren(self)




    def lf(self):

        localctx = ECLsubsetParser.LfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_lf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.match(ECLsubsetParser.LF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUOTE(self):
            return self.getToken(ECLsubsetParser.QUOTE, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_qm

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQm" ):
                return visitor.visitQm(self)
            else:
                return visitor.visitChildren(self)




    def qm(self):

        localctx = ECLsubsetParser.QmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_qm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            self.match(ECLsubsetParser.QUOTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKSLASH(self):
            return self.getToken(ECLsubsetParser.BACKSLASH, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_bs

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBs" ):
                return visitor.visitBs(self)
            else:
                return visitor.visitChildren(self)




    def bs(self):

        localctx = ECLsubsetParser.BsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_bs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self.match(ECLsubsetParser.BACKSLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DigitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZERO(self):
            return self.getToken(ECLsubsetParser.ZERO, 0)

        def ONE(self):
            return self.getToken(ECLsubsetParser.ONE, 0)

        def TWO(self):
            return self.getToken(ECLsubsetParser.TWO, 0)

        def THREE(self):
            return self.getToken(ECLsubsetParser.THREE, 0)

        def FOUR(self):
            return self.getToken(ECLsubsetParser.FOUR, 0)

        def FIVE(self):
            return self.getToken(ECLsubsetParser.FIVE, 0)

        def SIX(self):
            return self.getToken(ECLsubsetParser.SIX, 0)

        def SEVEN(self):
            return self.getToken(ECLsubsetParser.SEVEN, 0)

        def EIGHT(self):
            return self.getToken(ECLsubsetParser.EIGHT, 0)

        def NINE(self):
            return self.getToken(ECLsubsetParser.NINE, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_digit

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDigit" ):
                return visitor.visitDigit(self)
            else:
                return visitor.visitChildren(self)




    def digit(self):

        localctx = ECLsubsetParser.DigitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_digit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.ZERO) | (1 << ECLsubsetParser.ONE) | (1 << ECLsubsetParser.TWO) | (1 << ECLsubsetParser.THREE) | (1 << ECLsubsetParser.FOUR) | (1 << ECLsubsetParser.FIVE) | (1 << ECLsubsetParser.SIX) | (1 << ECLsubsetParser.SEVEN) | (1 << ECLsubsetParser.EIGHT) | (1 << ECLsubsetParser.NINE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ZeroContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZERO(self):
            return self.getToken(ECLsubsetParser.ZERO, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_zero

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZero" ):
                return visitor.visitZero(self)
            else:
                return visitor.visitChildren(self)




    def zero(self):

        localctx = ECLsubsetParser.ZeroContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_zero)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.match(ECLsubsetParser.ZERO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DigitnonzeroContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONE(self):
            return self.getToken(ECLsubsetParser.ONE, 0)

        def TWO(self):
            return self.getToken(ECLsubsetParser.TWO, 0)

        def THREE(self):
            return self.getToken(ECLsubsetParser.THREE, 0)

        def FOUR(self):
            return self.getToken(ECLsubsetParser.FOUR, 0)

        def FIVE(self):
            return self.getToken(ECLsubsetParser.FIVE, 0)

        def SIX(self):
            return self.getToken(ECLsubsetParser.SIX, 0)

        def SEVEN(self):
            return self.getToken(ECLsubsetParser.SEVEN, 0)

        def EIGHT(self):
            return self.getToken(ECLsubsetParser.EIGHT, 0)

        def NINE(self):
            return self.getToken(ECLsubsetParser.NINE, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_digitnonzero

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDigitnonzero" ):
                return visitor.visitDigitnonzero(self)
            else:
                return visitor.visitChildren(self)




    def digitnonzero(self):

        localctx = ECLsubsetParser.DigitnonzeroContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_digitnonzero)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.ONE) | (1 << ECLsubsetParser.TWO) | (1 << ECLsubsetParser.THREE) | (1 << ECLsubsetParser.FOUR) | (1 << ECLsubsetParser.FIVE) | (1 << ECLsubsetParser.SIX) | (1 << ECLsubsetParser.SEVEN) | (1 << ECLsubsetParser.EIGHT) | (1 << ECLsubsetParser.NINE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NonwsnonpipeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLAMATION(self):
            return self.getToken(ECLsubsetParser.EXCLAMATION, 0)

        def QUOTE(self):
            return self.getToken(ECLsubsetParser.QUOTE, 0)

        def POUND(self):
            return self.getToken(ECLsubsetParser.POUND, 0)

        def DOLLAR(self):
            return self.getToken(ECLsubsetParser.DOLLAR, 0)

        def PERCENT(self):
            return self.getToken(ECLsubsetParser.PERCENT, 0)

        def AMPERSAND(self):
            return self.getToken(ECLsubsetParser.AMPERSAND, 0)

        def APOSTROPHE(self):
            return self.getToken(ECLsubsetParser.APOSTROPHE, 0)

        def LEFT_PAREN(self):
            return self.getToken(ECLsubsetParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(ECLsubsetParser.RIGHT_PAREN, 0)

        def ASTERISK(self):
            return self.getToken(ECLsubsetParser.ASTERISK, 0)

        def PLUS(self):
            return self.getToken(ECLsubsetParser.PLUS, 0)

        def COMMA(self):
            return self.getToken(ECLsubsetParser.COMMA, 0)

        def DASH(self):
            return self.getToken(ECLsubsetParser.DASH, 0)

        def PERIOD(self):
            return self.getToken(ECLsubsetParser.PERIOD, 0)

        def SLASH(self):
            return self.getToken(ECLsubsetParser.SLASH, 0)

        def ZERO(self):
            return self.getToken(ECLsubsetParser.ZERO, 0)

        def ONE(self):
            return self.getToken(ECLsubsetParser.ONE, 0)

        def TWO(self):
            return self.getToken(ECLsubsetParser.TWO, 0)

        def THREE(self):
            return self.getToken(ECLsubsetParser.THREE, 0)

        def FOUR(self):
            return self.getToken(ECLsubsetParser.FOUR, 0)

        def FIVE(self):
            return self.getToken(ECLsubsetParser.FIVE, 0)

        def SIX(self):
            return self.getToken(ECLsubsetParser.SIX, 0)

        def SEVEN(self):
            return self.getToken(ECLsubsetParser.SEVEN, 0)

        def EIGHT(self):
            return self.getToken(ECLsubsetParser.EIGHT, 0)

        def NINE(self):
            return self.getToken(ECLsubsetParser.NINE, 0)

        def COLON(self):
            return self.getToken(ECLsubsetParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(ECLsubsetParser.SEMICOLON, 0)

        def LESS_THAN(self):
            return self.getToken(ECLsubsetParser.LESS_THAN, 0)

        def EQUALS(self):
            return self.getToken(ECLsubsetParser.EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(ECLsubsetParser.GREATER_THAN, 0)

        def QUESTION(self):
            return self.getToken(ECLsubsetParser.QUESTION, 0)

        def AT(self):
            return self.getToken(ECLsubsetParser.AT, 0)

        def CAP_A(self):
            return self.getToken(ECLsubsetParser.CAP_A, 0)

        def CAP_B(self):
            return self.getToken(ECLsubsetParser.CAP_B, 0)

        def CAP_C(self):
            return self.getToken(ECLsubsetParser.CAP_C, 0)

        def CAP_D(self):
            return self.getToken(ECLsubsetParser.CAP_D, 0)

        def CAP_E(self):
            return self.getToken(ECLsubsetParser.CAP_E, 0)

        def CAP_F(self):
            return self.getToken(ECLsubsetParser.CAP_F, 0)

        def CAP_G(self):
            return self.getToken(ECLsubsetParser.CAP_G, 0)

        def CAP_H(self):
            return self.getToken(ECLsubsetParser.CAP_H, 0)

        def CAP_I(self):
            return self.getToken(ECLsubsetParser.CAP_I, 0)

        def CAP_J(self):
            return self.getToken(ECLsubsetParser.CAP_J, 0)

        def CAP_K(self):
            return self.getToken(ECLsubsetParser.CAP_K, 0)

        def CAP_L(self):
            return self.getToken(ECLsubsetParser.CAP_L, 0)

        def CAP_M(self):
            return self.getToken(ECLsubsetParser.CAP_M, 0)

        def CAP_N(self):
            return self.getToken(ECLsubsetParser.CAP_N, 0)

        def CAP_O(self):
            return self.getToken(ECLsubsetParser.CAP_O, 0)

        def CAP_P(self):
            return self.getToken(ECLsubsetParser.CAP_P, 0)

        def CAP_Q(self):
            return self.getToken(ECLsubsetParser.CAP_Q, 0)

        def CAP_R(self):
            return self.getToken(ECLsubsetParser.CAP_R, 0)

        def CAP_S(self):
            return self.getToken(ECLsubsetParser.CAP_S, 0)

        def CAP_T(self):
            return self.getToken(ECLsubsetParser.CAP_T, 0)

        def CAP_U(self):
            return self.getToken(ECLsubsetParser.CAP_U, 0)

        def CAP_V(self):
            return self.getToken(ECLsubsetParser.CAP_V, 0)

        def CAP_W(self):
            return self.getToken(ECLsubsetParser.CAP_W, 0)

        def CAP_X(self):
            return self.getToken(ECLsubsetParser.CAP_X, 0)

        def CAP_Y(self):
            return self.getToken(ECLsubsetParser.CAP_Y, 0)

        def CAP_Z(self):
            return self.getToken(ECLsubsetParser.CAP_Z, 0)

        def LEFT_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_BRACE, 0)

        def BACKSLASH(self):
            return self.getToken(ECLsubsetParser.BACKSLASH, 0)

        def RIGHT_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_BRACE, 0)

        def CARAT(self):
            return self.getToken(ECLsubsetParser.CARAT, 0)

        def UNDERSCORE(self):
            return self.getToken(ECLsubsetParser.UNDERSCORE, 0)

        def ACCENT(self):
            return self.getToken(ECLsubsetParser.ACCENT, 0)

        def A(self):
            return self.getToken(ECLsubsetParser.A, 0)

        def B(self):
            return self.getToken(ECLsubsetParser.B, 0)

        def C(self):
            return self.getToken(ECLsubsetParser.C, 0)

        def D(self):
            return self.getToken(ECLsubsetParser.D, 0)

        def E(self):
            return self.getToken(ECLsubsetParser.E, 0)

        def F(self):
            return self.getToken(ECLsubsetParser.F, 0)

        def G(self):
            return self.getToken(ECLsubsetParser.G, 0)

        def H(self):
            return self.getToken(ECLsubsetParser.H, 0)

        def I(self):
            return self.getToken(ECLsubsetParser.I, 0)

        def J(self):
            return self.getToken(ECLsubsetParser.J, 0)

        def K(self):
            return self.getToken(ECLsubsetParser.K, 0)

        def L(self):
            return self.getToken(ECLsubsetParser.L, 0)

        def M(self):
            return self.getToken(ECLsubsetParser.M, 0)

        def N(self):
            return self.getToken(ECLsubsetParser.N, 0)

        def O(self):
            return self.getToken(ECLsubsetParser.O, 0)

        def P(self):
            return self.getToken(ECLsubsetParser.P, 0)

        def Q(self):
            return self.getToken(ECLsubsetParser.Q, 0)

        def R(self):
            return self.getToken(ECLsubsetParser.R, 0)

        def S(self):
            return self.getToken(ECLsubsetParser.S, 0)

        def T(self):
            return self.getToken(ECLsubsetParser.T, 0)

        def U(self):
            return self.getToken(ECLsubsetParser.U, 0)

        def V(self):
            return self.getToken(ECLsubsetParser.V, 0)

        def W(self):
            return self.getToken(ECLsubsetParser.W, 0)

        def X(self):
            return self.getToken(ECLsubsetParser.X, 0)

        def Y(self):
            return self.getToken(ECLsubsetParser.Y, 0)

        def Z(self):
            return self.getToken(ECLsubsetParser.Z, 0)

        def LEFT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_CURLY_BRACE, 0)

        def RIGHT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_CURLY_BRACE, 0)

        def TILDE(self):
            return self.getToken(ECLsubsetParser.TILDE, 0)

        def UTF8_LETTER(self):
            return self.getToken(ECLsubsetParser.UTF8_LETTER, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_nonwsnonpipe

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNonwsnonpipe" ):
                return visitor.visitNonwsnonpipe(self)
            else:
                return visitor.visitChildren(self)




    def nonwsnonpipe(self):

        localctx = ECLsubsetParser.NonwsnonpipeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_nonwsnonpipe)
        self._la = 0 # Token type
        try:
            self.state = 327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ECLsubsetParser.EXCLAMATION, ECLsubsetParser.QUOTE, ECLsubsetParser.POUND, ECLsubsetParser.DOLLAR, ECLsubsetParser.PERCENT, ECLsubsetParser.AMPERSAND, ECLsubsetParser.APOSTROPHE, ECLsubsetParser.LEFT_PAREN, ECLsubsetParser.RIGHT_PAREN, ECLsubsetParser.ASTERISK, ECLsubsetParser.PLUS, ECLsubsetParser.COMMA, ECLsubsetParser.DASH, ECLsubsetParser.PERIOD, ECLsubsetParser.SLASH, ECLsubsetParser.ZERO, ECLsubsetParser.ONE, ECLsubsetParser.TWO, ECLsubsetParser.THREE, ECLsubsetParser.FOUR, ECLsubsetParser.FIVE, ECLsubsetParser.SIX, ECLsubsetParser.SEVEN, ECLsubsetParser.EIGHT, ECLsubsetParser.NINE, ECLsubsetParser.COLON, ECLsubsetParser.SEMICOLON, ECLsubsetParser.LESS_THAN, ECLsubsetParser.EQUALS, ECLsubsetParser.GREATER_THAN, ECLsubsetParser.QUESTION, ECLsubsetParser.AT, ECLsubsetParser.CAP_A, ECLsubsetParser.CAP_B, ECLsubsetParser.CAP_C, ECLsubsetParser.CAP_D, ECLsubsetParser.CAP_E, ECLsubsetParser.CAP_F, ECLsubsetParser.CAP_G, ECLsubsetParser.CAP_H, ECLsubsetParser.CAP_I, ECLsubsetParser.CAP_J, ECLsubsetParser.CAP_K, ECLsubsetParser.CAP_L, ECLsubsetParser.CAP_M, ECLsubsetParser.CAP_N, ECLsubsetParser.CAP_O, ECLsubsetParser.CAP_P, ECLsubsetParser.CAP_Q, ECLsubsetParser.CAP_R, ECLsubsetParser.CAP_S, ECLsubsetParser.CAP_T, ECLsubsetParser.CAP_U, ECLsubsetParser.CAP_V, ECLsubsetParser.CAP_W, ECLsubsetParser.CAP_X, ECLsubsetParser.CAP_Y, ECLsubsetParser.CAP_Z, ECLsubsetParser.LEFT_BRACE, ECLsubsetParser.BACKSLASH, ECLsubsetParser.RIGHT_BRACE, ECLsubsetParser.CARAT, ECLsubsetParser.UNDERSCORE, ECLsubsetParser.ACCENT, ECLsubsetParser.A, ECLsubsetParser.B, ECLsubsetParser.C, ECLsubsetParser.D, ECLsubsetParser.E, ECLsubsetParser.F, ECLsubsetParser.G, ECLsubsetParser.H, ECLsubsetParser.I, ECLsubsetParser.J, ECLsubsetParser.K, ECLsubsetParser.L, ECLsubsetParser.M, ECLsubsetParser.N, ECLsubsetParser.O, ECLsubsetParser.P, ECLsubsetParser.Q, ECLsubsetParser.R, ECLsubsetParser.S, ECLsubsetParser.T, ECLsubsetParser.U, ECLsubsetParser.V, ECLsubsetParser.W, ECLsubsetParser.X, ECLsubsetParser.Y, ECLsubsetParser.Z, ECLsubsetParser.LEFT_CURLY_BRACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 324
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ECLsubsetParser.EXCLAMATION) | (1 << ECLsubsetParser.QUOTE) | (1 << ECLsubsetParser.POUND) | (1 << ECLsubsetParser.DOLLAR) | (1 << ECLsubsetParser.PERCENT) | (1 << ECLsubsetParser.AMPERSAND) | (1 << ECLsubsetParser.APOSTROPHE) | (1 << ECLsubsetParser.LEFT_PAREN) | (1 << ECLsubsetParser.RIGHT_PAREN) | (1 << ECLsubsetParser.ASTERISK) | (1 << ECLsubsetParser.PLUS) | (1 << ECLsubsetParser.COMMA) | (1 << ECLsubsetParser.DASH) | (1 << ECLsubsetParser.PERIOD) | (1 << ECLsubsetParser.SLASH) | (1 << ECLsubsetParser.ZERO) | (1 << ECLsubsetParser.ONE) | (1 << ECLsubsetParser.TWO) | (1 << ECLsubsetParser.THREE) | (1 << ECLsubsetParser.FOUR) | (1 << ECLsubsetParser.FIVE) | (1 << ECLsubsetParser.SIX) | (1 << ECLsubsetParser.SEVEN) | (1 << ECLsubsetParser.EIGHT) | (1 << ECLsubsetParser.NINE) | (1 << ECLsubsetParser.COLON) | (1 << ECLsubsetParser.SEMICOLON) | (1 << ECLsubsetParser.LESS_THAN) | (1 << ECLsubsetParser.EQUALS) | (1 << ECLsubsetParser.GREATER_THAN) | (1 << ECLsubsetParser.QUESTION) | (1 << ECLsubsetParser.AT) | (1 << ECLsubsetParser.CAP_A) | (1 << ECLsubsetParser.CAP_B) | (1 << ECLsubsetParser.CAP_C) | (1 << ECLsubsetParser.CAP_D) | (1 << ECLsubsetParser.CAP_E) | (1 << ECLsubsetParser.CAP_F) | (1 << ECLsubsetParser.CAP_G) | (1 << ECLsubsetParser.CAP_H) | (1 << ECLsubsetParser.CAP_I) | (1 << ECLsubsetParser.CAP_J) | (1 << ECLsubsetParser.CAP_K) | (1 << ECLsubsetParser.CAP_L) | (1 << ECLsubsetParser.CAP_M) | (1 << ECLsubsetParser.CAP_N) | (1 << ECLsubsetParser.CAP_O) | (1 << ECLsubsetParser.CAP_P) | (1 << ECLsubsetParser.CAP_Q) | (1 << ECLsubsetParser.CAP_R) | (1 << ECLsubsetParser.CAP_S) | (1 << ECLsubsetParser.CAP_T) | (1 << ECLsubsetParser.CAP_U) | (1 << ECLsubsetParser.CAP_V) | (1 << ECLsubsetParser.CAP_W) | (1 << ECLsubsetParser.CAP_X) | (1 << ECLsubsetParser.CAP_Y) | (1 << ECLsubsetParser.CAP_Z))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ECLsubsetParser.LEFT_BRACE - 64)) | (1 << (ECLsubsetParser.BACKSLASH - 64)) | (1 << (ECLsubsetParser.RIGHT_BRACE - 64)) | (1 << (ECLsubsetParser.CARAT - 64)) | (1 << (ECLsubsetParser.UNDERSCORE - 64)) | (1 << (ECLsubsetParser.ACCENT - 64)) | (1 << (ECLsubsetParser.A - 64)) | (1 << (ECLsubsetParser.B - 64)) | (1 << (ECLsubsetParser.C - 64)) | (1 << (ECLsubsetParser.D - 64)) | (1 << (ECLsubsetParser.E - 64)) | (1 << (ECLsubsetParser.F - 64)) | (1 << (ECLsubsetParser.G - 64)) | (1 << (ECLsubsetParser.H - 64)) | (1 << (ECLsubsetParser.I - 64)) | (1 << (ECLsubsetParser.J - 64)) | (1 << (ECLsubsetParser.K - 64)) | (1 << (ECLsubsetParser.L - 64)) | (1 << (ECLsubsetParser.M - 64)) | (1 << (ECLsubsetParser.N - 64)) | (1 << (ECLsubsetParser.O - 64)) | (1 << (ECLsubsetParser.P - 64)) | (1 << (ECLsubsetParser.Q - 64)) | (1 << (ECLsubsetParser.R - 64)) | (1 << (ECLsubsetParser.S - 64)) | (1 << (ECLsubsetParser.T - 64)) | (1 << (ECLsubsetParser.U - 64)) | (1 << (ECLsubsetParser.V - 64)) | (1 << (ECLsubsetParser.W - 64)) | (1 << (ECLsubsetParser.X - 64)) | (1 << (ECLsubsetParser.Y - 64)) | (1 << (ECLsubsetParser.Z - 64)) | (1 << (ECLsubsetParser.LEFT_CURLY_BRACE - 64)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ECLsubsetParser.RIGHT_CURLY_BRACE, ECLsubsetParser.TILDE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 325
                _la = self._input.LA(1)
                if not(_la==ECLsubsetParser.RIGHT_CURLY_BRACE or _la==ECLsubsetParser.TILDE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ECLsubsetParser.UTF8_LETTER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 326
                self.match(ECLsubsetParser.UTF8_LETTER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnynonescapedcharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sp(self):
            return self.getTypedRuleContext(ECLsubsetParser.SpContext,0)


        def htab(self):
            return self.getTypedRuleContext(ECLsubsetParser.HtabContext,0)


        def cr(self):
            return self.getTypedRuleContext(ECLsubsetParser.CrContext,0)


        def lf(self):
            return self.getTypedRuleContext(ECLsubsetParser.LfContext,0)


        def SPACE(self):
            return self.getToken(ECLsubsetParser.SPACE, 0)

        def EXCLAMATION(self):
            return self.getToken(ECLsubsetParser.EXCLAMATION, 0)

        def POUND(self):
            return self.getToken(ECLsubsetParser.POUND, 0)

        def DOLLAR(self):
            return self.getToken(ECLsubsetParser.DOLLAR, 0)

        def PERCENT(self):
            return self.getToken(ECLsubsetParser.PERCENT, 0)

        def AMPERSAND(self):
            return self.getToken(ECLsubsetParser.AMPERSAND, 0)

        def APOSTROPHE(self):
            return self.getToken(ECLsubsetParser.APOSTROPHE, 0)

        def LEFT_PAREN(self):
            return self.getToken(ECLsubsetParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(ECLsubsetParser.RIGHT_PAREN, 0)

        def ASTERISK(self):
            return self.getToken(ECLsubsetParser.ASTERISK, 0)

        def PLUS(self):
            return self.getToken(ECLsubsetParser.PLUS, 0)

        def COMMA(self):
            return self.getToken(ECLsubsetParser.COMMA, 0)

        def DASH(self):
            return self.getToken(ECLsubsetParser.DASH, 0)

        def PERIOD(self):
            return self.getToken(ECLsubsetParser.PERIOD, 0)

        def SLASH(self):
            return self.getToken(ECLsubsetParser.SLASH, 0)

        def ZERO(self):
            return self.getToken(ECLsubsetParser.ZERO, 0)

        def ONE(self):
            return self.getToken(ECLsubsetParser.ONE, 0)

        def TWO(self):
            return self.getToken(ECLsubsetParser.TWO, 0)

        def THREE(self):
            return self.getToken(ECLsubsetParser.THREE, 0)

        def FOUR(self):
            return self.getToken(ECLsubsetParser.FOUR, 0)

        def FIVE(self):
            return self.getToken(ECLsubsetParser.FIVE, 0)

        def SIX(self):
            return self.getToken(ECLsubsetParser.SIX, 0)

        def SEVEN(self):
            return self.getToken(ECLsubsetParser.SEVEN, 0)

        def EIGHT(self):
            return self.getToken(ECLsubsetParser.EIGHT, 0)

        def NINE(self):
            return self.getToken(ECLsubsetParser.NINE, 0)

        def COLON(self):
            return self.getToken(ECLsubsetParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(ECLsubsetParser.SEMICOLON, 0)

        def LESS_THAN(self):
            return self.getToken(ECLsubsetParser.LESS_THAN, 0)

        def EQUALS(self):
            return self.getToken(ECLsubsetParser.EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(ECLsubsetParser.GREATER_THAN, 0)

        def QUESTION(self):
            return self.getToken(ECLsubsetParser.QUESTION, 0)

        def AT(self):
            return self.getToken(ECLsubsetParser.AT, 0)

        def CAP_A(self):
            return self.getToken(ECLsubsetParser.CAP_A, 0)

        def CAP_B(self):
            return self.getToken(ECLsubsetParser.CAP_B, 0)

        def CAP_C(self):
            return self.getToken(ECLsubsetParser.CAP_C, 0)

        def CAP_D(self):
            return self.getToken(ECLsubsetParser.CAP_D, 0)

        def CAP_E(self):
            return self.getToken(ECLsubsetParser.CAP_E, 0)

        def CAP_F(self):
            return self.getToken(ECLsubsetParser.CAP_F, 0)

        def CAP_G(self):
            return self.getToken(ECLsubsetParser.CAP_G, 0)

        def CAP_H(self):
            return self.getToken(ECLsubsetParser.CAP_H, 0)

        def CAP_I(self):
            return self.getToken(ECLsubsetParser.CAP_I, 0)

        def CAP_J(self):
            return self.getToken(ECLsubsetParser.CAP_J, 0)

        def CAP_K(self):
            return self.getToken(ECLsubsetParser.CAP_K, 0)

        def CAP_L(self):
            return self.getToken(ECLsubsetParser.CAP_L, 0)

        def CAP_M(self):
            return self.getToken(ECLsubsetParser.CAP_M, 0)

        def CAP_N(self):
            return self.getToken(ECLsubsetParser.CAP_N, 0)

        def CAP_O(self):
            return self.getToken(ECLsubsetParser.CAP_O, 0)

        def CAP_P(self):
            return self.getToken(ECLsubsetParser.CAP_P, 0)

        def CAP_Q(self):
            return self.getToken(ECLsubsetParser.CAP_Q, 0)

        def CAP_R(self):
            return self.getToken(ECLsubsetParser.CAP_R, 0)

        def CAP_S(self):
            return self.getToken(ECLsubsetParser.CAP_S, 0)

        def CAP_T(self):
            return self.getToken(ECLsubsetParser.CAP_T, 0)

        def CAP_U(self):
            return self.getToken(ECLsubsetParser.CAP_U, 0)

        def CAP_V(self):
            return self.getToken(ECLsubsetParser.CAP_V, 0)

        def CAP_W(self):
            return self.getToken(ECLsubsetParser.CAP_W, 0)

        def CAP_X(self):
            return self.getToken(ECLsubsetParser.CAP_X, 0)

        def CAP_Y(self):
            return self.getToken(ECLsubsetParser.CAP_Y, 0)

        def CAP_Z(self):
            return self.getToken(ECLsubsetParser.CAP_Z, 0)

        def LEFT_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_BRACE, 0)

        def RIGHT_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_BRACE, 0)

        def CARAT(self):
            return self.getToken(ECLsubsetParser.CARAT, 0)

        def UNDERSCORE(self):
            return self.getToken(ECLsubsetParser.UNDERSCORE, 0)

        def ACCENT(self):
            return self.getToken(ECLsubsetParser.ACCENT, 0)

        def A(self):
            return self.getToken(ECLsubsetParser.A, 0)

        def B(self):
            return self.getToken(ECLsubsetParser.B, 0)

        def C(self):
            return self.getToken(ECLsubsetParser.C, 0)

        def D(self):
            return self.getToken(ECLsubsetParser.D, 0)

        def E(self):
            return self.getToken(ECLsubsetParser.E, 0)

        def F(self):
            return self.getToken(ECLsubsetParser.F, 0)

        def G(self):
            return self.getToken(ECLsubsetParser.G, 0)

        def H(self):
            return self.getToken(ECLsubsetParser.H, 0)

        def I(self):
            return self.getToken(ECLsubsetParser.I, 0)

        def J(self):
            return self.getToken(ECLsubsetParser.J, 0)

        def K(self):
            return self.getToken(ECLsubsetParser.K, 0)

        def L(self):
            return self.getToken(ECLsubsetParser.L, 0)

        def M(self):
            return self.getToken(ECLsubsetParser.M, 0)

        def N(self):
            return self.getToken(ECLsubsetParser.N, 0)

        def O(self):
            return self.getToken(ECLsubsetParser.O, 0)

        def P(self):
            return self.getToken(ECLsubsetParser.P, 0)

        def Q(self):
            return self.getToken(ECLsubsetParser.Q, 0)

        def R(self):
            return self.getToken(ECLsubsetParser.R, 0)

        def S(self):
            return self.getToken(ECLsubsetParser.S, 0)

        def T(self):
            return self.getToken(ECLsubsetParser.T, 0)

        def U(self):
            return self.getToken(ECLsubsetParser.U, 0)

        def V(self):
            return self.getToken(ECLsubsetParser.V, 0)

        def W(self):
            return self.getToken(ECLsubsetParser.W, 0)

        def X(self):
            return self.getToken(ECLsubsetParser.X, 0)

        def Y(self):
            return self.getToken(ECLsubsetParser.Y, 0)

        def Z(self):
            return self.getToken(ECLsubsetParser.Z, 0)

        def LEFT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.LEFT_CURLY_BRACE, 0)

        def PIPE(self):
            return self.getToken(ECLsubsetParser.PIPE, 0)

        def RIGHT_CURLY_BRACE(self):
            return self.getToken(ECLsubsetParser.RIGHT_CURLY_BRACE, 0)

        def TILDE(self):
            return self.getToken(ECLsubsetParser.TILDE, 0)

        def UTF8_LETTER(self):
            return self.getToken(ECLsubsetParser.UTF8_LETTER, 0)

        def getRuleIndex(self):
            return ECLsubsetParser.RULE_anynonescapedchar

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnynonescapedchar" ):
                return visitor.visitAnynonescapedchar(self)
            else:
                return visitor.visitChildren(self)




    def anynonescapedchar(self):

        localctx = ECLsubsetParser.AnynonescapedcharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_anynonescapedchar)
        self._la = 0 # Token type
        try:
            self.state = 337
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 329
                self.sp()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 330
                self.htab()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 331
                self.cr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 332
                self.lf()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 333
                _la = self._input.LA(1)
                if not(_la==ECLsubsetParser.SPACE or _la==ECLsubsetParser.EXCLAMATION):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 334
                _la = self._input.LA(1)
                if not(((((_la - 8)) & ~0x3f) == 0 and ((1 << (_la - 8)) & ((1 << (ECLsubsetParser.POUND - 8)) | (1 << (ECLsubsetParser.DOLLAR - 8)) | (1 << (ECLsubsetParser.PERCENT - 8)) | (1 << (ECLsubsetParser.AMPERSAND - 8)) | (1 << (ECLsubsetParser.APOSTROPHE - 8)) | (1 << (ECLsubsetParser.LEFT_PAREN - 8)) | (1 << (ECLsubsetParser.RIGHT_PAREN - 8)) | (1 << (ECLsubsetParser.ASTERISK - 8)) | (1 << (ECLsubsetParser.PLUS - 8)) | (1 << (ECLsubsetParser.COMMA - 8)) | (1 << (ECLsubsetParser.DASH - 8)) | (1 << (ECLsubsetParser.PERIOD - 8)) | (1 << (ECLsubsetParser.SLASH - 8)) | (1 << (ECLsubsetParser.ZERO - 8)) | (1 << (ECLsubsetParser.ONE - 8)) | (1 << (ECLsubsetParser.TWO - 8)) | (1 << (ECLsubsetParser.THREE - 8)) | (1 << (ECLsubsetParser.FOUR - 8)) | (1 << (ECLsubsetParser.FIVE - 8)) | (1 << (ECLsubsetParser.SIX - 8)) | (1 << (ECLsubsetParser.SEVEN - 8)) | (1 << (ECLsubsetParser.EIGHT - 8)) | (1 << (ECLsubsetParser.NINE - 8)) | (1 << (ECLsubsetParser.COLON - 8)) | (1 << (ECLsubsetParser.SEMICOLON - 8)) | (1 << (ECLsubsetParser.LESS_THAN - 8)) | (1 << (ECLsubsetParser.EQUALS - 8)) | (1 << (ECLsubsetParser.GREATER_THAN - 8)) | (1 << (ECLsubsetParser.QUESTION - 8)) | (1 << (ECLsubsetParser.AT - 8)) | (1 << (ECLsubsetParser.CAP_A - 8)) | (1 << (ECLsubsetParser.CAP_B - 8)) | (1 << (ECLsubsetParser.CAP_C - 8)) | (1 << (ECLsubsetParser.CAP_D - 8)) | (1 << (ECLsubsetParser.CAP_E - 8)) | (1 << (ECLsubsetParser.CAP_F - 8)) | (1 << (ECLsubsetParser.CAP_G - 8)) | (1 << (ECLsubsetParser.CAP_H - 8)) | (1 << (ECLsubsetParser.CAP_I - 8)) | (1 << (ECLsubsetParser.CAP_J - 8)) | (1 << (ECLsubsetParser.CAP_K - 8)) | (1 << (ECLsubsetParser.CAP_L - 8)) | (1 << (ECLsubsetParser.CAP_M - 8)) | (1 << (ECLsubsetParser.CAP_N - 8)) | (1 << (ECLsubsetParser.CAP_O - 8)) | (1 << (ECLsubsetParser.CAP_P - 8)) | (1 << (ECLsubsetParser.CAP_Q - 8)) | (1 << (ECLsubsetParser.CAP_R - 8)) | (1 << (ECLsubsetParser.CAP_S - 8)) | (1 << (ECLsubsetParser.CAP_T - 8)) | (1 << (ECLsubsetParser.CAP_U - 8)) | (1 << (ECLsubsetParser.CAP_V - 8)) | (1 << (ECLsubsetParser.CAP_W - 8)) | (1 << (ECLsubsetParser.CAP_X - 8)) | (1 << (ECLsubsetParser.CAP_Y - 8)) | (1 << (ECLsubsetParser.CAP_Z - 8)) | (1 << (ECLsubsetParser.LEFT_BRACE - 8)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 335
                _la = self._input.LA(1)
                if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (ECLsubsetParser.RIGHT_BRACE - 66)) | (1 << (ECLsubsetParser.CARAT - 66)) | (1 << (ECLsubsetParser.UNDERSCORE - 66)) | (1 << (ECLsubsetParser.ACCENT - 66)) | (1 << (ECLsubsetParser.A - 66)) | (1 << (ECLsubsetParser.B - 66)) | (1 << (ECLsubsetParser.C - 66)) | (1 << (ECLsubsetParser.D - 66)) | (1 << (ECLsubsetParser.E - 66)) | (1 << (ECLsubsetParser.F - 66)) | (1 << (ECLsubsetParser.G - 66)) | (1 << (ECLsubsetParser.H - 66)) | (1 << (ECLsubsetParser.I - 66)) | (1 << (ECLsubsetParser.J - 66)) | (1 << (ECLsubsetParser.K - 66)) | (1 << (ECLsubsetParser.L - 66)) | (1 << (ECLsubsetParser.M - 66)) | (1 << (ECLsubsetParser.N - 66)) | (1 << (ECLsubsetParser.O - 66)) | (1 << (ECLsubsetParser.P - 66)) | (1 << (ECLsubsetParser.Q - 66)) | (1 << (ECLsubsetParser.R - 66)) | (1 << (ECLsubsetParser.S - 66)) | (1 << (ECLsubsetParser.T - 66)) | (1 << (ECLsubsetParser.U - 66)) | (1 << (ECLsubsetParser.V - 66)) | (1 << (ECLsubsetParser.W - 66)) | (1 << (ECLsubsetParser.X - 66)) | (1 << (ECLsubsetParser.Y - 66)) | (1 << (ECLsubsetParser.Z - 66)) | (1 << (ECLsubsetParser.LEFT_CURLY_BRACE - 66)) | (1 << (ECLsubsetParser.PIPE - 66)) | (1 << (ECLsubsetParser.RIGHT_CURLY_BRACE - 66)) | (1 << (ECLsubsetParser.TILDE - 66)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 336
                self.match(ECLsubsetParser.UTF8_LETTER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscapedcharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ECLsubsetParser.BsContext)
            else:
                return self.getTypedRuleContext(ECLsubsetParser.BsContext,i)


        def qm(self):
            return self.getTypedRuleContext(ECLsubsetParser.QmContext,0)


        def getRuleIndex(self):
            return ECLsubsetParser.RULE_escapedchar

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEscapedchar" ):
                return visitor.visitEscapedchar(self)
            else:
                return visitor.visitChildren(self)




    def escapedchar(self):

        localctx = ECLsubsetParser.EscapedcharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_escapedchar)
        try:
            self.state = 345
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 339
                self.bs()
                self.state = 340
                self.qm()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 342
                self.bs()
                self.state = 343
                self.bs()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





